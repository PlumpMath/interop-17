let module ErrnoError = {
  type t;
  external create: unit => t = "ErrnoError" [@@bs.new]; 
  external errno: t => float = "" [@@bs.get];
  external code: t => string = "" [@@bs.get];
  external path: t => string = "" [@@bs.get];
  external syscall: t => string = "" [@@bs.get];
};
type TODO;
type TODO;
type TODO;
let module Buffer = {
  type t;
  external create: unit => t = "Buffer" [@@bs.new]; 
  external constructor: t => (TODO => encoding::(option buffer$Encoding.t) => unit) = "" [@@bs.send];
  external length: t => float = "" [@@bs.get];
  external compare: t => (Buffer.t => float) = "" [@@bs.send];
  external copy: t => (Buffer.t => targetStart::(option float) => sourceStart::(option float) => sourceEnd::(option float) => float) = "" [@@bs.send];
  external entries: t => (unit => Iterator.t) = "" [@@bs.send];
  external equals: t => (Buffer.t => bool) = "" [@@bs.send];
  external fill: t => (TODO => offset::(option float) => end::(option float) => unit) = "" [@@bs.send];
  external includes: t => (TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding.t) => bool) = "" [@@bs.send];
  external indexOf: t => (TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding.t) => float) = "" [@@bs.send];
  external inspect: t => (unit => string) = "" [@@bs.send];
  external keys: t => (unit => Iterator.t) = "" [@@bs.send];
  external lastIndexOf: t => (TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding.t) => float) = "" [@@bs.send];
  external readDoubleBE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readDoubleLE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readFloatBE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readFloatLE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readInt16BE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readInt16LE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readInt32BE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readInt32LE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readInt8: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readIntBE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readIntLE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUInt16BE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUInt16LE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUInt32BE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUInt32LE: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUInt8: t => (float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUIntBE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external readUIntLE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external slice: t => (start::(option float) => end::(option float) => Buffer.t) = "" [@@bs.send];
  external swap16: t => (unit => Buffer.t) = "" [@@bs.send];
  external swap32: t => (unit => Buffer.t) = "" [@@bs.send];
  external toJSON: t => (unit => buffer$ToJSONRet.t) = "" [@@bs.send];
  external toString: t => (encoding::(option buffer$Encoding.t) => start::(option float) => end::(option float) => string) = "" [@@bs.send];
  external values: t => (unit => Iterator.t) = "" [@@bs.send];
  external write: t => (string => offset::(option float) => length::(option float) => encoding::(option buffer$Encoding.t) => unit) = "" [@@bs.send];
  external writeDoubleBE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeDoubleLE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeFloatBE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeFloatLE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeInt16BE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeInt16LE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeInt32BE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeInt32LE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeInt8: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeIntBE: t => (float => float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeIntLE: t => (float => float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUInt16BE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUInt16LE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUInt32BE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUInt32LE: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUInt8: t => (float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUIntBE: t => (float => float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external writeUIntLE: t => (float => float => float => noAssert::(option bool) => float) = "" [@@bs.send];
  external alloc: (float => fill::(option TODO) => encoding::(option buffer$Encoding.t) => Buffer.t) = "" [@@bs.val];
  external allocUnsafe: (float => Buffer.t) = "" [@@bs.val];
  external allocUnsafeSlow: (float => Buffer.t) = "" [@@bs.val];
  external byteLength: (TODO => encoding::(option buffer$Encoding.t) => float) = "" [@@bs.val];
  external compare: (Buffer.t => Buffer.t => float) = "" [@@bs.val];
  external concat: (array TODO => totalLength::(option float) => Buffer.t) = "" [@@bs.val];
  external from: (array float => unit => Buffer.t) = "" [@@bs.val];
  external from: (Buffer.t => unit => Buffer.t) = "" [@@bs.val];
  external from: (string => encoding::(option buffer$Encoding.t) => Buffer.t) = "" [@@bs.val];
  external from: (ArrayBuffer.t => byteOffset::(option float) => length::(option float) => Buffer.t) = "" [@@bs.val];
  external isBuffer: ('a => bool) = "" [@@bs.val];
  external isEncoding: (string => bool) = "" [@@bs.val];
};
type TODO;
let module Child_process$Error = {
  type t;
  external create: unit => t = "child_process$Error" [@@bs.new]; 
  external code: t => float = "" [@@bs.get];
  external signal: t => TODO = "" [@@bs.get];
};
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
let module Child_process$ChildProcess = {
  type t;
  external create: unit => t = "child_process$ChildProcess" [@@bs.new]; 
  external stdin: t => stream$Writable.t = "" [@@bs.get];
  external stdout: t => stream$Readable.t = "" [@@bs.get];
  external stderr: t => stream$Readable.t = "" [@@bs.get];
  external pid: t => float = "" [@@bs.get];
  external connected: t => bool = "" [@@bs.get];
  external disconnect: t => (unit => unit) = "" [@@bs.send];
  external kill: t => (signal::(option string) => unit) = "" [@@bs.send];
  external send: t => (Object.t => sendHandle::(option child_process$Handle.t) => bool) = "" [@@bs.send];
};
type TODO;
type TODO;
let module Crypto$Cipher = {
  type t;
  external create: unit => t = "crypto$Cipher" [@@bs.new]; 
  external final: t => (TODO => string) = "" [@@bs.send];
  external final: t => (unit => Buffer.t) = "" [@@bs.send];
  external getAuthTag: t => (unit => Buffer.t) = "" [@@bs.send];
  external setAAD: t => (Buffer.t => unit) = "" [@@bs.send];
  external setAuthTag: t => (Buffer.t => unit) = "" [@@bs.send];
  external setAutoPadding: t => (auto_padding::(option bool) => crypto$Cipher.t) = "" [@@bs.send];
  external update: t => (string => TODO => TODO => string) = "" [@@bs.send];
  external update: t => (string => TODO => unit => Buffer.t) = "" [@@bs.send];
  external update: t => (Buffer.t => unit => TODO => string) = "" [@@bs.send];
  external update: t => (Buffer.t => unit => unit => Buffer.t) = "" [@@bs.send];
};
type TODO;
type TODO;
let module Crypto$Decipher = {
  type t;
  external create: unit => t = "crypto$Decipher" [@@bs.new]; 
  external final: t => (TODO => string) = "" [@@bs.send];
  external final: t => (unit => Buffer.t) = "" [@@bs.send];
  external getAuthTag: t => (unit => Buffer.t) = "" [@@bs.send];
  external setAAD: t => (Buffer.t => unit) = "" [@@bs.send];
  external setAuthTag: t => (Buffer.t => unit) = "" [@@bs.send];
  external setAutoPadding: t => (auto_padding::(option bool) => crypto$Cipher.t) = "" [@@bs.send];
  external update: t => (string => TODO => TODO => string) = "" [@@bs.send];
  external update: t => (string => TODO => unit => Buffer.t) = "" [@@bs.send];
  external update: t => (Buffer.t => unit => TODO => string) = "" [@@bs.send];
  external update: t => (Buffer.t => unit => unit => Buffer.t) = "" [@@bs.send];
};
let module Crypto$Hash = {
  type t;
  external create: unit => t = "crypto$Hash" [@@bs.new]; 
  external digest: t => (TODO => string) = "" [@@bs.send];
  external digest: t => (unit => Buffer.t) = "" [@@bs.send];
  external update: t => (Buffer.t => input_encoding::(option unit) => crypto$Hash.t) = "" [@@bs.send];
  external update: t => (string => input_encoding::(option TODO) => crypto$Hash.t) = "" [@@bs.send];
};
let module Crypto$Hmac = {
  type t;
  external create: unit => t = "crypto$Hmac" [@@bs.new]; 
  external digest: t => (TODO => string) = "" [@@bs.send];
  external digest: t => (unit => Buffer.t) = "" [@@bs.send];
  external update: t => (Buffer.t => input_encoding::(option unit) => crypto$Hmac.t) = "" [@@bs.send];
  external update: t => (string => input_encoding::(option TODO) => crypto$Hmac.t) = "" [@@bs.send];
};
type TODO;
let module Crypto$Sign = {
  type t;
  external create: unit => t = "crypto$Sign" [@@bs.new]; 
  external sign: t => (crypto$Sign$private_key.t => TODO => string) = "" [@@bs.send];
  external sign: t => (crypto$Sign$private_key.t => unit => Buffer.t) = "" [@@bs.send];
  external update: t => (Buffer.t => input_encoding::(option unit) => crypto$Sign.t) = "" [@@bs.send];
  external update: t => (string => input_encoding::(option TODO) => crypto$Sign.t) = "" [@@bs.send];
};
let module Crypto$Verify = {
  type t;
  external create: unit => t = "crypto$Verify" [@@bs.new]; 
  external update: t => (Buffer.t => input_encoding::(option unit) => crypto$Verify.t) = "" [@@bs.send];
  external update: t => (string => input_encoding::(option TODO) => crypto$Verify.t) = "" [@@bs.send];
  external verify: t => (string => string => TODO => bool) = "" [@@bs.send];
  external verify: t => (string => Buffer.t => unit => bool) = "" [@@bs.send];
};
type TODO;
type TODO;
let module Events$EventEmitter = {
  type t;
  external create: unit => t = "events$EventEmitter" [@@bs.new]; 
  external listenerCount: (events$EventEmitter.t => string => float) = "" [@@bs.val];
  external addListener: t => (string => (unit => unit) => events$EventEmitter.t) = "" [@@bs.send];
  external emit: t => (string => array 'rest => bool) = "" [@@bs.send] [@@bs.splice];
  external listeners: t => (string => array TODO) = "" [@@bs.send];
  external listenerCount: t => (string => float) = "" [@@bs.send];
  external on: t => (string => (unit => unit) => events$EventEmitter.t) = "" [@@bs.send];
  external once: t => (string => (unit => unit) => events$EventEmitter.t) = "" [@@bs.send];
  external removeAllListeners: t => (event::(option string) => events$EventEmitter.t) = "" [@@bs.send];
  external removeListener: t => (string => (unit => unit) => events$EventEmitter.t) = "" [@@bs.send];
  external setMaxListeners: t => (float => unit) = "" [@@bs.send];
  external getMaxListeners: t => (unit => float) = "" [@@bs.send];
};
let module Domain$Domain = {
  type t;
  external create: unit => t = "domain$Domain" [@@bs.new]; 
  external members: t => array TODO = "" [@@bs.get];
  external add: t => (events$EventEmitter.t => unit) = "" [@@bs.send];
  external bind: t => ((unit => unit) => (unit => unit)) = "" [@@bs.send];
  external dispose: t => (unit => unit) = "" [@@bs.send];
  external enter: t => (unit => unit) = "" [@@bs.send];
  external exit: t => (unit => unit) = "" [@@bs.send];
  external intercept: t => ((unit => unit) => (unit => unit)) = "" [@@bs.send];
  external remove: t => (events$EventEmitter.t => unit) = "" [@@bs.send];
  external run: t => ((unit => unit) => unit) = "" [@@bs.send];
};
let module Http$IncomingMessage = {
  type t;
  external create: unit => t = "http$IncomingMessage" [@@bs.new]; 
  external headers: t => Object.t = "" [@@bs.get];
  external httpVersion: t => string = "" [@@bs.get];
  external method: t => string = "" [@@bs.get];
  external trailers: t => Object.t = "" [@@bs.get];
  external setTimeout: t => (float => (unit => unit) => unit) = "" [@@bs.send];
  external socket: t => net$Socket.t = "" [@@bs.get];
  external statusCode: t => float = "" [@@bs.get];
  external url: t => string = "" [@@bs.get];
};
let module Http$ClientRequest = {
  type t;
  external create: unit => t = "http$ClientRequest" [@@bs.new]; 
  external flushHeaders: t => (unit => unit) = "" [@@bs.send];
  external abort: t => (unit => unit) = "" [@@bs.send];
  external setTimeout: t => (float => callback::(option (unit => unit)) => unit) = "" [@@bs.send];
  external setNoDelay: t => (noDelay::(option bool) => unit) = "" [@@bs.send];
  external setSocketKeepAlive: t => (enable::(option bool) => initialDelay::(option float) => unit) = "" [@@bs.send];
};
let module Http$ServerResponse = {
  type t;
  external create: unit => t = "http$ServerResponse" [@@bs.new]; 
  external addTrailers: t => (TODO => unit) = "" [@@bs.send];
  external finished: t => bool = "" [@@bs.get];
  external getHeader: t => (string => unit) = "" [@@bs.send];
  external headersSent: t => bool = "" [@@bs.get];
  external removeHeader: t => (string => unit) = "" [@@bs.send];
  external sendDate: t => bool = "" [@@bs.get];
  external setHeader: t => (string => TODO => unit) = "" [@@bs.send];
  external setTimeout: t => (float => callback::(option (unit => unit)) => http$ServerResponse.t) = "" [@@bs.send];
  external statusCode: t => float = "" [@@bs.get];
  external statusMessage: t => string = "" [@@bs.get];
  external writeContinue: t => (unit => unit) = "" [@@bs.send];
  external writeHead: t => (float => statusMessage::(option string) => headers::(option TODO) => unit) = "" [@@bs.send];
  external writeHead: t => (float => headers::(option TODO) => unit) = "" [@@bs.send];
};
let module Net$Socket = {
  type t;
  external create: unit => t = "net$Socket" [@@bs.new]; 
  external constructor: t => (options::(option Object.t) => unit) = "" [@@bs.send];
  external address: t => (unit => net$Socket$address.t) = "" [@@bs.send];
  external bufferSize: t => float = "" [@@bs.get];
  external bytesRead: t => float = "" [@@bs.get];
  external bytesWritten: t => float = "" [@@bs.get];
  external connect: t => (Object.t => connectListener::(option function.t) => unit) = "" [@@bs.send];
  external destroy: t => (unit => unit) = "" [@@bs.send];
  external _end: t => (chunk::(option TODO) => encodingOrCallback::(option TODO) => callback::(option ('a => unit)) => unit) = "" [@@bs.send];
  external localAddress: t => string = "" [@@bs.get];
  external localPort: t => float = "" [@@bs.get];
  external pause: t => (unit => stream$Readable.t) = "" [@@bs.send];
  external ref: t => (unit => net$Socket.t) = "" [@@bs.send];
  external remoteAddress: t => TODO = "" [@@bs.get];
  external remoteFamily: t => string = "" [@@bs.get];
  external remotePort: t => float = "" [@@bs.get];
  external resume: t => (unit => stream$Readable.t) = "" [@@bs.send];
  external setEncoding: t => (encoding::(option string) => stream$Readable.t) = "" [@@bs.send];
  external setKeepAlive: t => (enable::(option bool) => initialDelay::(option float) => net$Socket.t) = "" [@@bs.send];
  external setNoDelay: t => (noDelay::(option bool) => net$Socket.t) = "" [@@bs.send];
  external setTimeout: t => (float => callback::(option function.t) => net$Socket.t) = "" [@@bs.send];
  external unref: t => (unit => net$Socket.t) = "" [@@bs.send];
  external write: t => (chunk::(option TODO) => encodingOrCallback::(option TODO) => callback::(option ('a => unit)) => bool) = "" [@@bs.send];
};
let module Net$Server = {
  type t;
  external create: unit => t = "net$Server" [@@bs.new]; 
  external listen: t => (float => hostname::(option string) => backlog::(option float) => callback::(option (unit => unit)) => net$Server.t) = "" [@@bs.send];
  external listen: t => (string => callback::(option (unit => unit)) => net$Server.t) = "" [@@bs.send];
  external listen: t => (Object.t => callback::(option (unit => unit)) => net$Server.t) = "" [@@bs.send];
  external close: t => (callback::(option (unit => unit)) => net$Server.t) = "" [@@bs.send];
  external address: t => (unit => net$Socket$address.t) = "" [@@bs.send];
  external connections: t => float = "" [@@bs.get];
  external maxConnections: t => float = "" [@@bs.get];
  external getConnections: t => ((unit => unit) => unit) = "" [@@bs.send];
  external ref: t => (unit => net$Server.t) = "" [@@bs.send];
  external unref: t => (unit => net$Server.t) = "" [@@bs.send];
};
type TODO;
type TODO;
type TODO;
let module Readline$Interface = {
  type t;
  external create: unit => t = "readline$Interface" [@@bs.new]; 
  external close: t => (unit => unit) = "" [@@bs.send];
  external pause: t => (unit => unit) = "" [@@bs.send];
  external prompt: t => (preserveCursor::(option bool) => unit) = "" [@@bs.send];
  external question: t => (string => (string => unit) => unit) = "" [@@bs.send];
  external resume: t => (unit => unit) = "" [@@bs.send];
  external setPrompt: t => (string => unit) = "" [@@bs.send];
  external write: t => (TODO => key::(option TODO) => unit) = "" [@@bs.send];
};
let module Stream$Stream = {
  type t;
  external create: unit => t = "stream$Stream" [@@bs.new]; 
};
type TODO;
let module Stream$Readable = {
  type t;
  external create: unit => t = "stream$Readable" [@@bs.new]; 
  external constructor: t => (options::(option readableStreamOptions.t) => unit) = "" [@@bs.send];
  external setEncoding: t => (string => stream$Readable.t) = "" [@@bs.send];
  external isPaused: t => (unit => bool) = "" [@@bs.send];
  external pause: t => (unit => stream$Readable.t) = "" [@@bs.send];
  external pipe: t => (stream$Duplex.t => options::(option TODO) => stream$Duplex.t) = "" [@@bs.send];
  external pipe: t => (stream$Writable.t => options::(option TODO) => stream$Writable.t) = "" [@@bs.send];
  external read: t => (size::(option float) => TODO) = "" [@@bs.send];
  external resume: t => (unit => stream$Readable.t) = "" [@@bs.send];
  external unpipe: t => (dest::(option TODO) => unit) = "" [@@bs.send];
  external unshift: t => (TODO => unit) = "" [@@bs.send];
  external push: t => (TODO => encoding::(option string) => bool) = "" [@@bs.send];
  external wrap: t => ('a => stream$Readable.t) = "" [@@bs.send];
};
type TODO;
let module Stream$Writable = {
  type t;
  external create: unit => t = "stream$Writable" [@@bs.new]; 
  external constructor: t => (options::(option writableStreamOptions.t) => unit) = "" [@@bs.send];
  external cork: t => (unit => unit) = "" [@@bs.send];
  external _end: t => (chunkOrEncodingOrCallback::(option TODO) => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => unit) = "" [@@bs.send];
  external setDefaultEncoding: t => (string => bool) = "" [@@bs.send];
  external uncork: t => (unit => unit) = "" [@@bs.send];
  external write: t => (TODO => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => bool) = "" [@@bs.send];
  external __write: t => (TODO => string => (TODO => data::(option TODO) => unit) => bool) = "" [@@bs.send];
};
type TODO;
let module Stream$Duplex = {
  type t;
  external create: unit => t = "stream$Duplex" [@@bs.new]; 
  external constructor: t => (options::(option duplexStreamOptions.t) => unit) = "" [@@bs.send];
  external cork: t => (unit => unit) = "" [@@bs.send];
  external _end: t => (chunkOrEncodingOrCallback::(option TODO) => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => unit) = "" [@@bs.send];
  external setDefaultEncoding: t => (string => bool) = "" [@@bs.send];
  external uncork: t => (unit => unit) = "" [@@bs.send];
  external write: t => (TODO => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => bool) = "" [@@bs.send];
  external __write: t => (TODO => string => (TODO => data::(option TODO) => unit) => bool) = "" [@@bs.send];
};
let module Stream$Transform = {
  type t;
  external create: unit => t = "stream$Transform" [@@bs.new]; 
  external __transform: t => (TODO => string => (TODO => data::(option TODO) => unit) => unit) = "" [@@bs.send];
  external __flush: t => ((TODO => unit) => unit) = "" [@@bs.send];
};
let module Stream$PassThrough = {
  type t;
  external create: unit => t = "stream$PassThrough" [@@bs.new]; 
};
let module Tty$ReadStream = {
  type t;
  external create: unit => t = "tty$ReadStream" [@@bs.new]; 
  external isRaw: t => bool = "" [@@bs.get];
  external setRawMode: t => (bool => unit) = "" [@@bs.send];
  let isTTY = true;
};
let module Tty$WriteStream = {
  type t;
  external create: unit => t = "tty$WriteStream" [@@bs.new]; 
  external columns: t => float = "" [@@bs.get];
  external rows: t => float = "" [@@bs.get];
  let isTTY = true;
};
let module String_decoder$StringDecoder = {
  type t;
  external create: unit => t = "string_decoder$StringDecoder" [@@bs.new]; 
  external constructor: t => (encoding::(option TODO) => unit) = "" [@@bs.send];
  external _end: t => (unit => unit) = "" [@@bs.send];
  external write: t => (Buffer.t => string) = "" [@@bs.send];
};
let module Tls$TLSSocket = {
  type t;
  external create: unit => t = "tls$TLSSocket" [@@bs.new]; 
  external constructor: t => (net$Socket.t => options::(option Object.t) => unit) = "" [@@bs.send];
  external authorized: t => bool = "" [@@bs.get];
  external authorizationError: t => TODO = "" [@@bs.get];
  let encrypted = true;
  external getCipher: t => (unit => TODO) = "" [@@bs.send];
  external getEphemeralKeyInfo: t => (unit => TODO) = "" [@@bs.send];
  external getPeerCertificate: t => (detailed::(option bool) => TODO) = "" [@@bs.send];
  external getSession: t => (unit => TODO) = "" [@@bs.send];
  external getTLSTicket: t => (unit => TODO) = "" [@@bs.send];
  external renegotiate: t => (Object.t => (unit => unit) => TODO) = "" [@@bs.send];
  external setMaxSendFragment: t => (float => bool) = "" [@@bs.send];
};
let module Tls$Server = {
  type t;
  external create: unit => t = "tls$Server" [@@bs.new]; 
  external listen: t => (float => hostname::(option string) => backlog::(option float) => callback::(option (unit => unit)) => tls$Server.t) = "" [@@bs.send];
  external listen: t => (string => callback::(option (unit => unit)) => tls$Server.t) = "" [@@bs.send];
  external listen: t => (Object.t => callback::(option (unit => unit)) => tls$Server.t) = "" [@@bs.send];
  external close: t => (callback::(option (unit => unit)) => tls$Server.t) = "" [@@bs.send];
  external addContext: t => (string => Object.t => unit) = "" [@@bs.send];
  external getTicketKeys: t => (unit => Buffer.t) = "" [@@bs.send];
  external setTicketKeys: t => (Buffer.t => unit) = "" [@@bs.send];
};
type TODO;
let module Vm$Script = {
  type t;
  external create: unit => t = "vm$Script" [@@bs.new]; 
  external constructor: t => (string => Object.t => unit) = "" [@@bs.send];
  external cachedData: t => TODO = "" [@@bs.get];
  external cachedDataRejected: t => TODO = "" [@@bs.get];
  external cachedDataProduced: t => TODO = "" [@@bs.get];
  external runInContext: t => (vm$Context.t => options::(option vm$ScriptOptions.t) => 'a) = "" [@@bs.send];
  external runInNewContext: t => (sandbox::(option Object.t) => options::(option vm$ScriptOptions.t) => 'a) = "" [@@bs.send];
  external runInThisContext: t => (options::(option vm$ScriptOptions.t) => 'a) = "" [@@bs.send];
};
let module Vm$Context = {
  type t;
  external create: unit => t = "vm$Context" [@@bs.new]; 
};
type TODO;
type TODO;
type TODO;
let module Process = {
  type t;
  external create: unit => t = "Process" [@@bs.new]; 
  external abort: t => (unit => unit) = "" [@@bs.send];
  external arch: t => string = "" [@@bs.get];
  external argv: t => array string = "" [@@bs.get];
  external chdir: t => (string => unit) = "" [@@bs.send];
  external config: t => Object.t = "" [@@bs.get];
  external connected: t => bool = "" [@@bs.get];
  external cwd: t => (unit => string) = "" [@@bs.send];
  external disconnect: t => (unit => unit) = "" [@@bs.get];
  let module Env = { 
};
  external execArgv: t => array string = "" [@@bs.get];
  external execPath: t => string = "" [@@bs.get];
  external exit: t => (code::(option float) => unit) = "" [@@bs.send];
  external exitCode: t => float = "" [@@bs.get];
  external getegid: t => (unit => float) = "" [@@bs.get];
  external geteuid: t => (unit => float) = "" [@@bs.get];
  external getgid: t => (unit => float) = "" [@@bs.get];
  external getgroups: t => (unit => array float) = "" [@@bs.get];
  external getuid: t => (unit => float) = "" [@@bs.get];
  external hrtime: t => (unit => TODO) = "" [@@bs.send];
  external initgroups: t => (TODO => TODO => unit) = "" [@@bs.get];
  external kill: t => (float => signal::(option TODO) => unit) = "" [@@bs.send];
  external mainModule: t => Object.t = "" [@@bs.get];
  external memoryUsage: t => (unit => TODO) = "" [@@bs.send];
  external nextTick: t => ((unit => unit) => unit) = "" [@@bs.send];
  external pid: t => float = "" [@@bs.get];
  external platform: t => string = "" [@@bs.get];
  let module Release = { 
  external name: string = "Process.release.name" [@@bs.val];
  external lts: string = "Process.release.lts" [@@bs.val];
  external sourceUrl: string = "Process.release.sourceUrl" [@@bs.val];
  external headersUrl: string = "Process.release.headersUrl" [@@bs.val];
  external libUrl: string = "Process.release.libUrl" [@@bs.val];
};
  external send: t => ('a => sendHandleOrCallback::(option TODO) => callback::(option (unit => unit)) => unit) = "" [@@bs.get];
  external setegid: t => (TODO => unit) = "" [@@bs.get];
  external seteuid: t => (TODO => unit) = "" [@@bs.get];
  external setgid: t => (TODO => unit) = "" [@@bs.get];
  external setgroups: t => (array TODO => unit) = "" [@@bs.get];
  external setuid: t => (TODO => unit) = "" [@@bs.get];
  external stderr: t => TODO = "" [@@bs.get];
  external stdin: t => TODO = "" [@@bs.get];
  external stdout: t => TODO = "" [@@bs.get];
  external title: t => string = "" [@@bs.get];
  external umask: t => (float => float) = "" [@@bs.send];
  external uptime: t => (unit => float) = "" [@@bs.send];
  external version: t => string = "" [@@bs.get];
  let module Versions = { 
};
};
let module ProcessInstance = {
  external abort: (unit => unit) = "process.abort" [@@bs.send];
  external arch: string = "process.arch" [@@bs.val];
  external argv: array string = "process.argv" [@@bs.val];
  external chdir: (string => unit) = "process.chdir" [@@bs.send];
  external config: Object.t = "process.config" [@@bs.val];
  external connected: bool = "process.connected" [@@bs.val];
  external cwd: (unit => string) = "process.cwd" [@@bs.send];
  external disconnect: (unit => unit) = "process.disconnect" [@@bs.val];
  let module Env = { 
  };
  external execArgv: array string = "process.execArgv" [@@bs.val];
  external execPath: string = "process.execPath" [@@bs.val];
  external exit: (code::(option float) => unit) = "process.exit" [@@bs.send];
  external exitCode: float = "process.exitCode" [@@bs.val];
  external getegid: (unit => float) = "process.getegid" [@@bs.val];
  external geteuid: (unit => float) = "process.geteuid" [@@bs.val];
  external getgid: (unit => float) = "process.getgid" [@@bs.val];
  external getgroups: (unit => array float) = "process.getgroups" [@@bs.val];
  external getuid: (unit => float) = "process.getuid" [@@bs.val];
  external hrtime: (unit => TODO) = "process.hrtime" [@@bs.send];
  external initgroups: (TODO => TODO => unit) = "process.initgroups" [@@bs.val];
  external kill: (float => signal::(option TODO) => unit) = "process.kill" [@@bs.send];
  external mainModule: Object.t = "process.mainModule" [@@bs.val];
  external memoryUsage: (unit => TODO) = "process.memoryUsage" [@@bs.send];
  external nextTick: ((unit => unit) => unit) = "process.nextTick" [@@bs.send];
  external pid: float = "process.pid" [@@bs.val];
  external platform: string = "process.platform" [@@bs.val];
  let module Release = { 
  external name: string = "process.release.name" [@@bs.val];
  external lts: string = "process.release.lts" [@@bs.val];
  external sourceUrl: string = "process.release.sourceUrl" [@@bs.val];
  external headersUrl: string = "process.release.headersUrl" [@@bs.val];
  external libUrl: string = "process.release.libUrl" [@@bs.val];
  };
  external send: ('a => sendHandleOrCallback::(option TODO) => callback::(option (unit => unit)) => unit) = "process.send" [@@bs.val];
  external setegid: (TODO => unit) = "process.setegid" [@@bs.val];
  external seteuid: (TODO => unit) = "process.seteuid" [@@bs.val];
  external setgid: (TODO => unit) = "process.setgid" [@@bs.val];
  external setgroups: (array TODO => unit) = "process.setgroups" [@@bs.val];
  external setuid: (TODO => unit) = "process.setuid" [@@bs.val];
  external stderr: TODO = "process.stderr" [@@bs.val];
  external stdin: TODO = "process.stdin" [@@bs.val];
  external stdout: TODO = "process.stdout" [@@bs.val];
  external title: string = "process.title" [@@bs.val];
  external umask: (float => float) = "process.umask" [@@bs.send];
  external uptime: (unit => float) = "process.uptime" [@@bs.send];
  external version: string = "process.version" [@@bs.val];
  let module Versions = { 
  };
};
external ___filename: string = "__filename" [@@bs.val];
external ___dirname: string = "__dirname" [@@bs.val];
external setImmediate: ((array 'rest => 'a) => array 'rest => Object.t) = "setImmediate" [@@bs.val];
external clearImmediate: ('a => Object.t) = "clearImmediate" [@@bs.val];
