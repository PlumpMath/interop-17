type TODO;
type TODO;
type TODO;
let module Buffer = {
  type t;
  external constructor: t => TODO => encoding::(option buffer$Encoding) => unit = "" [@@bs.send];
  external length: float = "" [@@bs.get];
  external compare: t => Buffer => float = "" [@@bs.send];
  external copy: t => Buffer => targetStart::(option float) => sourceStart::(option float) => sourceEnd::(option float) => float = "" [@@bs.send];
  external entries: t => unit => Iterator = "" [@@bs.send];
  external equals: t => Buffer => bool = "" [@@bs.send];
  external fill: t => TODO => offset::(option float) => end::(option float) => unit = "" [@@bs.send];
  external includes: t => TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding) => bool = "" [@@bs.send];
  external indexOf: t => TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding) => float = "" [@@bs.send];
  external inspect: t => unit => string = "" [@@bs.send];
  external keys: t => unit => Iterator = "" [@@bs.send];
  external lastIndexOf: t => TODO => offsetOrEncoding::(option TODO) => encoding::(option buffer$Encoding) => float = "" [@@bs.send];
  external readDoubleBE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readDoubleLE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readFloatBE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readFloatLE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readInt16BE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readInt16LE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readInt32BE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readInt32LE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readInt8: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readIntBE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readIntLE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUInt16BE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUInt16LE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUInt32BE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUInt32LE: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUInt8: t => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUIntBE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external readUIntLE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external slice: t => start::(option float) => end::(option float) => Buffer = "" [@@bs.send];
  external swap16: t => unit => Buffer = "" [@@bs.send];
  external swap32: t => unit => Buffer = "" [@@bs.send];
  external toJSON: t => unit => buffer$ToJSONRet = "" [@@bs.send];
  external toString: t => encoding::(option buffer$Encoding) => start::(option float) => end::(option float) => string = "" [@@bs.send];
  external values: t => unit => Iterator = "" [@@bs.send];
  external write: t => string => offset::(option float) => length::(option float) => encoding::(option buffer$Encoding) => unit = "" [@@bs.send];
  external writeDoubleBE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeDoubleLE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeFloatBE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeFloatLE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeInt16BE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeInt16LE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeInt32BE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeInt32LE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeInt8: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeIntBE: t => float => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeIntLE: t => float => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUInt16BE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUInt16LE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUInt32BE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUInt32LE: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUInt8: t => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUIntBE: t => float => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external writeUIntLE: t => float => float => float => noAssert::(option bool) => float = "" [@@bs.send];
  external alloc: float => fill::(option TODO) => encoding::(option buffer$Encoding) => Buffer = "" [@@bs.val];
  external allocUnsafe: float => Buffer = "" [@@bs.val];
  external allocUnsafeSlow: float => Buffer = "" [@@bs.val];
  external byteLength: TODO => encoding::(option buffer$Encoding) => float = "" [@@bs.val];
  external compare: Buffer => Buffer => float = "" [@@bs.val];
  external concat: Array => totalLength::(option float) => Buffer = "" [@@bs.val];
  external from: Array => unit => Buffer = "" [@@bs.val];
  external from: Buffer => unit => Buffer = "" [@@bs.val];
  external from: string => encoding::(option buffer$Encoding) => Buffer = "" [@@bs.val];
  external from: ArrayBuffer => byteOffset::(option float) => length::(option float) => Buffer = "" [@@bs.val];
  external isBuffer: 'a => bool = "" [@@bs.val];
  external isEncoding: string => bool = "" [@@bs.val];
};
type TODO;
let module Child_process$Error = {
  type t;
  external code: float = "" [@@bs.get];
  external signal: TODO = "" [@@bs.get];
};
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
let module Child_process$ChildProcess = {
  type t;
  external stdin: stream$Writable = "" [@@bs.get];
  external stdout: stream$Readable = "" [@@bs.get];
  external stderr: stream$Readable = "" [@@bs.get];
  external pid: float = "" [@@bs.get];
  external connected: bool = "" [@@bs.get];
  external disconnect: t => unit => unit = "" [@@bs.send];
  external kill: t => signal::(option string) => unit = "" [@@bs.send];
  external send: t => Object => sendHandle::(option child_process$Handle) => bool = "" [@@bs.send];
};
type TODO;
type TODO;
let module Crypto$Cipher = {
  type t;
  external final: t => TODO => string = "" [@@bs.send];
  external final: t => unit => Buffer = "" [@@bs.send];
  external getAuthTag: t => unit => Buffer = "" [@@bs.send];
  external setAAD: t => Buffer => unit = "" [@@bs.send];
  external setAuthTag: t => Buffer => unit = "" [@@bs.send];
  external setAutoPadding: t => auto_padding::(option bool) => crypto$Cipher = "" [@@bs.send];
  external update: t => string => TODO => TODO => string = "" [@@bs.send];
  external update: t => string => TODO => unit => Buffer = "" [@@bs.send];
  external update: t => Buffer => unit => TODO => string = "" [@@bs.send];
  external update: t => Buffer => unit => unit => Buffer = "" [@@bs.send];
};
type TODO;
type TODO;
let module Crypto$Decipher = {
  type t;
  external final: t => TODO => string = "" [@@bs.send];
  external final: t => unit => Buffer = "" [@@bs.send];
  external getAuthTag: t => unit => Buffer = "" [@@bs.send];
  external setAAD: t => Buffer => unit = "" [@@bs.send];
  external setAuthTag: t => Buffer => unit = "" [@@bs.send];
  external setAutoPadding: t => auto_padding::(option bool) => crypto$Cipher = "" [@@bs.send];
  external update: t => string => TODO => TODO => string = "" [@@bs.send];
  external update: t => string => TODO => unit => Buffer = "" [@@bs.send];
  external update: t => Buffer => unit => TODO => string = "" [@@bs.send];
  external update: t => Buffer => unit => unit => Buffer = "" [@@bs.send];
};
let module Crypto$Hash = {
  type t;
  external digest: t => TODO => string = "" [@@bs.send];
  external digest: t => unit => Buffer = "" [@@bs.send];
  external update: t => Buffer => input_encoding::(option unit) => crypto$Hash = "" [@@bs.send];
  external update: t => string => input_encoding::(option TODO) => crypto$Hash = "" [@@bs.send];
};
let module Crypto$Hmac = {
  type t;
  external digest: t => TODO => string = "" [@@bs.send];
  external digest: t => unit => Buffer = "" [@@bs.send];
  external update: t => Buffer => input_encoding::(option unit) => crypto$Hmac = "" [@@bs.send];
  external update: t => string => input_encoding::(option TODO) => crypto$Hmac = "" [@@bs.send];
};
type TODO;
let module Crypto$Sign = {
  type t;
  external sign: t => crypto$Sign$private_key => TODO => string = "" [@@bs.send];
  external sign: t => crypto$Sign$private_key => unit => Buffer = "" [@@bs.send];
  external update: t => Buffer => input_encoding::(option unit) => crypto$Sign = "" [@@bs.send];
  external update: t => string => input_encoding::(option TODO) => crypto$Sign = "" [@@bs.send];
};
let module Crypto$Verify = {
  type t;
  external update: t => Buffer => input_encoding::(option unit) => crypto$Verify = "" [@@bs.send];
  external update: t => string => input_encoding::(option TODO) => crypto$Verify = "" [@@bs.send];
  external verify: t => string => string => TODO => bool = "" [@@bs.send];
  external verify: t => string => Buffer => unit => bool = "" [@@bs.send];
};
type TODO;
type TODO;
let module Events$EventEmitter = {
  type t;
  external listenerCount: events$EventEmitter => string => float = "" [@@bs.val];
  external addListener: t => string => (unit => unit) => events$EventEmitter = "" [@@bs.send];
  external emit: t => string => array 'rest => bool = "" [@@bs.send] [@@bs.splice];
  external listeners: t => string => Array = "" [@@bs.send];
  external listenerCount: t => string => float = "" [@@bs.send];
  external on: t => string => (unit => unit) => events$EventEmitter = "" [@@bs.send];
  external once: t => string => (unit => unit) => events$EventEmitter = "" [@@bs.send];
  external removeAllListeners: t => event::(option string) => events$EventEmitter = "" [@@bs.send];
  external removeListener: t => string => (unit => unit) => events$EventEmitter = "" [@@bs.send];
  external setMaxListeners: t => float => unit = "" [@@bs.send];
  external getMaxListeners: t => unit => float = "" [@@bs.send];
};
let module Domain$Domain = {
  type t;
  external members: Array = "" [@@bs.get];
  external add: t => events$EventEmitter => unit = "" [@@bs.send];
  external bind: t => (unit => unit) => (unit => unit) = "" [@@bs.send];
  external dispose: t => unit => unit = "" [@@bs.send];
  external enter: t => unit => unit = "" [@@bs.send];
  external exit: t => unit => unit = "" [@@bs.send];
  external intercept: t => (unit => unit) => (unit => unit) = "" [@@bs.send];
  external remove: t => events$EventEmitter => unit = "" [@@bs.send];
  external run: t => (unit => unit) => unit = "" [@@bs.send];
};
let module Http$IncomingMessage = {
  type t;
  external headers: Object = "" [@@bs.get];
  external httpVersion: string = "" [@@bs.get];
  external method: string = "" [@@bs.get];
  external trailers: Object = "" [@@bs.get];
  external setTimeout: t => float => (unit => unit) => unit = "" [@@bs.send];
  external socket: net$Socket = "" [@@bs.get];
  external statusCode: float = "" [@@bs.get];
  external url: string = "" [@@bs.get];
};
let module Http$ClientRequest = {
  type t;
  external flushHeaders: t => unit => unit = "" [@@bs.send];
  external abort: t => unit => unit = "" [@@bs.send];
  external setTimeout: t => float => callback::(option (unit => unit)) => unit = "" [@@bs.send];
  external setNoDelay: t => noDelay::(option bool) => unit = "" [@@bs.send];
  external setSocketKeepAlive: t => enable::(option bool) => initialDelay::(option float) => unit = "" [@@bs.send];
};
let module Http$ServerResponse = {
  type t;
  external addTrailers: t => TODO => unit = "" [@@bs.send];
  external finished: bool = "" [@@bs.get];
  external getHeader: t => string => unit = "" [@@bs.send];
  external headersSent: bool = "" [@@bs.get];
  external removeHeader: t => string => unit = "" [@@bs.send];
  external sendDate: bool = "" [@@bs.get];
  external setHeader: t => string => TODO => unit = "" [@@bs.send];
  external setTimeout: t => float => callback::(option (unit => unit)) => http$ServerResponse = "" [@@bs.send];
  external statusCode: float = "" [@@bs.get];
  external statusMessage: string = "" [@@bs.get];
  external writeContinue: t => unit => unit = "" [@@bs.send];
  external writeHead: t => float => statusMessage::(option string) => headers::(option TODO) => unit = "" [@@bs.send];
  external writeHead: t => float => headers::(option TODO) => unit = "" [@@bs.send];
};
let module Net$Socket = {
  type t;
  external constructor: t => options::(option Object) => unit = "" [@@bs.send];
  external address: t => unit => net$Socket$address = "" [@@bs.send];
  external bufferSize: float = "" [@@bs.get];
  external bytesRead: float = "" [@@bs.get];
  external bytesWritten: float = "" [@@bs.get];
  external connect: t => Object => connectListener::(option function) => unit = "" [@@bs.send];
  external destroy: t => unit => unit = "" [@@bs.send];
  external end: t => chunk::(option TODO) => encodingOrCallback::(option TODO) => callback::(option 'a => unit) => unit = "" [@@bs.send];
  external localAddress: string = "" [@@bs.get];
  external localPort: float = "" [@@bs.get];
  external pause: t => unit => stream$Readable = "" [@@bs.send];
  external ref: t => unit => net$Socket = "" [@@bs.send];
  external remoteAddress: TODO = "" [@@bs.get];
  external remoteFamily: string = "" [@@bs.get];
  external remotePort: float = "" [@@bs.get];
  external resume: t => unit => stream$Readable = "" [@@bs.send];
  external setEncoding: t => encoding::(option string) => stream$Readable = "" [@@bs.send];
  external setKeepAlive: t => enable::(option bool) => initialDelay::(option float) => net$Socket = "" [@@bs.send];
  external setNoDelay: t => noDelay::(option bool) => net$Socket = "" [@@bs.send];
  external setTimeout: t => float => callback::(option function) => net$Socket = "" [@@bs.send];
  external unref: t => unit => net$Socket = "" [@@bs.send];
  external write: t => chunk::(option TODO) => encodingOrCallback::(option TODO) => callback::(option 'a => unit) => bool = "" [@@bs.send];
};
let module Net$Server = {
  type t;
  external listen: t => float => hostname::(option string) => backlog::(option float) => callback::(option (unit => unit)) => net$Server = "" [@@bs.send];
  external listen: t => string => callback::(option (unit => unit)) => net$Server = "" [@@bs.send];
  external listen: t => Object => callback::(option (unit => unit)) => net$Server = "" [@@bs.send];
  external close: t => callback::(option (unit => unit)) => net$Server = "" [@@bs.send];
  external address: t => unit => net$Socket$address = "" [@@bs.send];
  external connections: float = "" [@@bs.get];
  external maxConnections: float = "" [@@bs.get];
  external getConnections: t => (unit => unit) => unit = "" [@@bs.send];
  external ref: t => unit => net$Server = "" [@@bs.send];
  external unref: t => unit => net$Server = "" [@@bs.send];
};
type TODO;
type TODO;
type TODO;
let module Readline$Interface = {
  type t;
  external close: t => unit => unit = "" [@@bs.send];
  external pause: t => unit => unit = "" [@@bs.send];
  external prompt: t => preserveCursor::(option bool) => unit = "" [@@bs.send];
  external question: t => string => string => unit => unit = "" [@@bs.send];
  external resume: t => unit => unit = "" [@@bs.send];
  external setPrompt: t => string => unit = "" [@@bs.send];
  external write: t => TODO => key::(option TODO) => unit = "" [@@bs.send];
};
let module Stream$Stream = {
  type t;
};
type TODO;
let module Stream$Readable = {
  type t;
  external constructor: t => options::(option readableStreamOptions) => unit = "" [@@bs.send];
  external setEncoding: t => string => stream$Readable = "" [@@bs.send];
  external isPaused: t => unit => bool = "" [@@bs.send];
  external pause: t => unit => stream$Readable = "" [@@bs.send];
  external pipe: t => stream$Duplex => options::(option TODO) => stream$Duplex = "" [@@bs.send];
  external pipe: t => stream$Writable => options::(option TODO) => stream$Writable = "" [@@bs.send];
  external read: t => size::(option float) => TODO = "" [@@bs.send];
  external resume: t => unit => stream$Readable = "" [@@bs.send];
  external unpipe: t => dest::(option TODO) => unit = "" [@@bs.send];
  external unshift: t => TODO => unit = "" [@@bs.send];
  external push: t => TODO => encoding::(option string) => bool = "" [@@bs.send];
  external wrap: t => 'a => stream$Readable = "" [@@bs.send];
};
type TODO;
let module Stream$Writable = {
  type t;
  external constructor: t => options::(option writableStreamOptions) => unit = "" [@@bs.send];
  external cork: t => unit => unit = "" [@@bs.send];
  external end: t => chunkOrEncodingOrCallback::(option TODO) => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => unit = "" [@@bs.send];
  external setDefaultEncoding: t => string => bool = "" [@@bs.send];
  external uncork: t => unit => unit = "" [@@bs.send];
  external write: t => TODO => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => bool = "" [@@bs.send];
  external __write: t => TODO => string => TODO => data::(option TODO) => unit => bool = "" [@@bs.send];
};
type TODO;
let module Stream$Duplex = {
  type t;
  external constructor: t => options::(option duplexStreamOptions) => unit = "" [@@bs.send];
  external cork: t => unit => unit = "" [@@bs.send];
  external end: t => chunkOrEncodingOrCallback::(option TODO) => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => unit = "" [@@bs.send];
  external setDefaultEncoding: t => string => bool = "" [@@bs.send];
  external uncork: t => unit => unit = "" [@@bs.send];
  external write: t => TODO => encodingOrCallback::(option TODO) => callback::(option (unit => unit)) => bool = "" [@@bs.send];
  external __write: t => TODO => string => TODO => data::(option TODO) => unit => bool = "" [@@bs.send];
};
let module Stream$Transform = {
  type t;
  external __transform: t => TODO => string => TODO => data::(option TODO) => unit => unit = "" [@@bs.send];
  external __flush: t => TODO => unit => unit = "" [@@bs.send];
};
let module Stream$PassThrough = {
  type t;
};
let module Tty$ReadStream = {
  type t;
  external isRaw: bool = "" [@@bs.get];
  external setRawMode: t => bool => unit = "" [@@bs.send];
  let isTTY = true;
};
let module Tty$WriteStream = {
  type t;
  external columns: float = "" [@@bs.get];
  external rows: float = "" [@@bs.get];
  let isTTY = true;
};
let module String_decoder$StringDecoder = {
  type t;
  external constructor: t => encoding::(option TODO) => unit = "" [@@bs.send];
  external end: t => unit => unit = "" [@@bs.send];
  external write: t => Buffer => string = "" [@@bs.send];
};
let module Tls$TLSSocket = {
  type t;
  external constructor: t => net$Socket => options::(option Object) => unit = "" [@@bs.send];
  external authorized: bool = "" [@@bs.get];
  external authorizationError: TODO = "" [@@bs.get];
  let encrypted = true;
  external getCipher: t => unit => TODO = "" [@@bs.send];
  external getEphemeralKeyInfo: t => unit => TODO = "" [@@bs.send];
  external getPeerCertificate: t => detailed::(option bool) => TODO = "" [@@bs.send];
  external getSession: t => unit => TODO = "" [@@bs.send];
  external getTLSTicket: t => unit => TODO = "" [@@bs.send];
  external renegotiate: t => Object => (unit => unit) => TODO = "" [@@bs.send];
  external setMaxSendFragment: t => float => bool = "" [@@bs.send];
};
let module Tls$Server = {
  type t;
  external listen: t => float => hostname::(option string) => backlog::(option float) => callback::(option (unit => unit)) => tls$Server = "" [@@bs.send];
  external listen: t => string => callback::(option (unit => unit)) => tls$Server = "" [@@bs.send];
  external listen: t => Object => callback::(option (unit => unit)) => tls$Server = "" [@@bs.send];
  external close: t => callback::(option (unit => unit)) => tls$Server = "" [@@bs.send];
  external addContext: t => string => Object => unit = "" [@@bs.send];
  external getTicketKeys: t => unit => Buffer = "" [@@bs.send];
  external setTicketKeys: t => Buffer => unit = "" [@@bs.send];
};
type TODO;
let module Vm$Script = {
  type t;
  external constructor: t => string => Object => unit = "" [@@bs.send];
  external cachedData: TODO = "" [@@bs.get];
  external cachedDataRejected: TODO = "" [@@bs.get];
  external cachedDataProduced: TODO = "" [@@bs.get];
  external runInContext: t => vm$Context => options::(option vm$ScriptOptions) => 'a = "" [@@bs.send];
  external runInNewContext: t => sandbox::(option Object) => options::(option vm$ScriptOptions) => 'a = "" [@@bs.send];
  external runInThisContext: t => options::(option vm$ScriptOptions) => 'a = "" [@@bs.send];
};
let module Vm$Context = {
  type t;
};
type TODO;
type TODO;
type TODO;
let module Process = {
  type t;
  external abort: t => unit => unit = "" [@@bs.send];
  external arch: string = "" [@@bs.get];
  external argv: Array = "" [@@bs.get];
  external chdir: t => string => unit = "" [@@bs.send];
  external config: Object = "" [@@bs.get];
  external connected: bool = "" [@@bs.get];
  external cwd: t => unit => string = "" [@@bs.send];
  external disconnect: unit => unit = "" [@@bs.get];
  external env: TODO = "" [@@bs.get];
  external execArgv: Array = "" [@@bs.get];
  external execPath: string = "" [@@bs.get];
  external exit: t => code::(option float) => unit = "" [@@bs.send];
  external exitCode: float = "" [@@bs.get];
  external getegid: unit => float = "" [@@bs.get];
  external geteuid: unit => float = "" [@@bs.get];
  external getgid: unit => float = "" [@@bs.get];
  external getgroups: unit => Array = "" [@@bs.get];
  external getuid: unit => float = "" [@@bs.get];
  external hrtime: t => unit => TODO = "" [@@bs.send];
  external initgroups: TODO => TODO => unit = "" [@@bs.get];
  external kill: t => float => signal::(option TODO) => unit = "" [@@bs.send];
  external mainModule: Object = "" [@@bs.get];
  external memoryUsage: t => unit => TODO = "" [@@bs.send];
  external nextTick: t => (unit => unit) => unit = "" [@@bs.send];
  external pid: float = "" [@@bs.get];
  external platform: string = "" [@@bs.get];
  external release: TODO = "" [@@bs.get];
  external send: 'a => sendHandleOrCallback::(option TODO) => callback::(option (unit => unit)) => unit = "" [@@bs.get];
  external setegid: TODO => unit = "" [@@bs.get];
  external seteuid: TODO => unit = "" [@@bs.get];
  external setgid: TODO => unit = "" [@@bs.get];
  external setgroups: Array => unit = "" [@@bs.get];
  external setuid: TODO => unit = "" [@@bs.get];
  external stderr: TODO = "" [@@bs.get];
  external stdin: TODO = "" [@@bs.get];
  external stdout: TODO = "" [@@bs.get];
  external title: string = "" [@@bs.get];
  external umask: t => float => float = "" [@@bs.send];
  external uptime: t => unit => float = "" [@@bs.send];
  external version: string = "" [@@bs.get];
  external versions: TODO = "" [@@bs.get];
};
let module ProcessInstance = {
  external abort: unit => unit = "process.abort" [@@bs.val];
  external arch: string = "process.arch" [@@bs.val];
  external argv: Array = "process.argv" [@@bs.val];
  external chdir: string => unit = "process.chdir" [@@bs.val];
  external config: Object = "process.config" [@@bs.val];
  external connected: bool = "process.connected" [@@bs.val];
  external cwd: unit => string = "process.cwd" [@@bs.val];
  external disconnect: unit => unit = "process.disconnect" [@@bs.val];
  external env: TODO = "process.env" [@@bs.val];
  external execArgv: Array = "process.execArgv" [@@bs.val];
  external execPath: string = "process.execPath" [@@bs.val];
  external exit: code::(option float) => unit = "process.exit" [@@bs.val];
  external exitCode: float = "process.exitCode" [@@bs.val];
  external getegid: unit => float = "process.getegid" [@@bs.val];
  external geteuid: unit => float = "process.geteuid" [@@bs.val];
  external getgid: unit => float = "process.getgid" [@@bs.val];
  external getgroups: unit => Array = "process.getgroups" [@@bs.val];
  external getuid: unit => float = "process.getuid" [@@bs.val];
  external hrtime: unit => TODO = "process.hrtime" [@@bs.val];
  external initgroups: TODO => TODO => unit = "process.initgroups" [@@bs.val];
  external kill: float => signal::(option TODO) => unit = "process.kill" [@@bs.val];
  external mainModule: Object = "process.mainModule" [@@bs.val];
  external memoryUsage: unit => TODO = "process.memoryUsage" [@@bs.val];
  external nextTick: (unit => unit) => unit = "process.nextTick" [@@bs.val];
  external pid: float = "process.pid" [@@bs.val];
  external platform: string = "process.platform" [@@bs.val];
  external release: TODO = "process.release" [@@bs.val];
  external send: 'a => sendHandleOrCallback::(option TODO) => callback::(option (unit => unit)) => unit = "process.send" [@@bs.val];
  external setegid: TODO => unit = "process.setegid" [@@bs.val];
  external seteuid: TODO => unit = "process.seteuid" [@@bs.val];
  external setgid: TODO => unit = "process.setgid" [@@bs.val];
  external setgroups: Array => unit = "process.setgroups" [@@bs.val];
  external setuid: TODO => unit = "process.setuid" [@@bs.val];
  external stderr: TODO = "process.stderr" [@@bs.val];
  external stdin: TODO = "process.stdin" [@@bs.val];
  external stdout: TODO = "process.stdout" [@@bs.val];
  external title: string = "process.title" [@@bs.val];
  external umask: float => float = "process.umask" [@@bs.val];
  external uptime: unit => float = "process.uptime" [@@bs.val];
  external version: string = "process.version" [@@bs.val];
  external versions: TODO = "process.versions" [@@bs.val];
};
external ___filename: string = "__filename" [@@bs.val];
external ___dirname: string = "__dirname" [@@bs.val];
external setImmediate: array 'rest => 'a => array 'rest => Object = "setImmediate" [@@bs.val];
external clearImmediate: 'a => Object = "clearImmediate" [@@bs.val];
