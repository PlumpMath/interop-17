let module Screen = {
  type t;
  external create: unit => t = "Screen" [@@bs.new];
  external availHeight: t => float = "" [@@bs.get];
  external availLeft: t => float = "" [@@bs.get];
  external availTop: t => float = "" [@@bs.get];
  external availWidth: t => float = "" [@@bs.get];
  external colorDepth: t => float = "" [@@bs.get];
  external height: t => float = "" [@@bs.get];
  external left: t => float = "" [@@bs.get];
  external mozOrientation: t => string = "" [@@bs.get];
  external onmozorientationchange: t => 'a = "" [@@bs.get];
  let module Orientation = {
  external lock: (unit => Promise.t) = "Screen.orientation.lock" [@@bs.send];
  external unlock: (unit => unit) = "Screen.orientation.unlock" [@@bs.send];
  external angle: float = "Screen.orientation.angle" [@@bs.val];
  external onchange: (unit => 'a) = "Screen.orientation.onchange" [@@bs.val];
  external _type: TODO = "Screen.orientation.type" [@@bs.val];
};
  external pixelDepth: t => float = "" [@@bs.get];
  external top: t => float = "" [@@bs.get];
  external width: t => float = "" [@@bs.get];
  external mozLockOrientation: t => (unit => unit) = "" [@@bs.get];
  external mozUnlockOrientation: t => (unit => unit) = "" [@@bs.get];
  external mozOrientation: t => string = "" [@@bs.get];
  external onmozorientationchange: t => (unit => unit) = "" [@@bs.get];
};
let module ScreenInstance = {
  external availHeight: float = "screen.availHeight" [@@bs.val];
  external availLeft: float = "screen.availLeft" [@@bs.val];
  external availTop: float = "screen.availTop" [@@bs.val];
  external availWidth: float = "screen.availWidth" [@@bs.val];
  external colorDepth: float = "screen.colorDepth" [@@bs.val];
  external height: float = "screen.height" [@@bs.val];
  external left: float = "screen.left" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: 'a = "screen.onmozorientationchange" [@@bs.val];
  let module Orientation = {
  external lock: (unit => Promise.t) = "screen.orientation.lock" [@@bs.send];
  external unlock: (unit => unit) = "screen.orientation.unlock" [@@bs.send];
  external angle: float = "screen.orientation.angle" [@@bs.val];
  external onchange: (unit => 'a) = "screen.orientation.onchange" [@@bs.val];
  external _type: TODO = "screen.orientation.type" [@@bs.val];
  };
  external pixelDepth: float = "screen.pixelDepth" [@@bs.val];
  external top: float = "screen.top" [@@bs.val];
  external width: float = "screen.width" [@@bs.val];
  external mozLockOrientation: (unit => unit) = "screen.mozLockOrientation" [@@bs.val];
  external mozUnlockOrientation: (unit => unit) = "screen.mozUnlockOrientation" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: (unit => unit) = "screen.onmozorientationchange" [@@bs.val];
};
external window: 'a = "window" [@@bs.val];
type TODO;
type TODO;
let module NavigatorCommon = {
  type t;
  external create: unit => t = "NavigatorCommon" [@@bs.new];
  let appName = "Netscape";
  external appVersion: t => string = "" [@@bs.get];
  external platform: t => string = "" [@@bs.get];
  external userAgent: t => string = "" [@@bs.get];
  external language: t => string = "" [@@bs.get];
  external languages: t => array string = "" [@@bs.get];
  external onLine: t => bool = "" [@@bs.get];
  external hardwareConcurrency: t => float = "" [@@bs.get];
};
let module Navigator = {
  type t;
  external create: unit => t = "Navigator" [@@bs.new];
  let appCodeName = "Mozilla";
  external buildID: t => string = "" [@@bs.get];
  external cookieEnabled: t => bool = "" [@@bs.get];
  external doNotTrack: t => 'a = "" [@@bs.get];
  external geolocation: t => Geolocation.t = "" [@@bs.get];
  external mediaDevices: t => Object.t = "" [@@bs.get];
  external javaEnabled: t => (unit => unit) = "" [@@bs.get];
  external maxTouchPoints: t => float = "" [@@bs.get];
  external mimeTypes: t => MimeTypeArray.t = "" [@@bs.get];
  external oscpu: t => string = "" [@@bs.get];
  external permissions: t => 'a = "" [@@bs.get];
  external plugins: t => PluginArray.t = "" [@@bs.get];
  let product = "Gecko";
  external productSub: t => TODO = "" [@@bs.get];
  external serviceWorker: t => Object.t = "" [@@bs.get];
  external vendor: t => TODO = "" [@@bs.get];
  let vendorSub = "";
  external getBattery: t => (unit => Promise.t) = "" [@@bs.get];
  external getGamepads: t => (unit => TODO) = "" [@@bs.get];
  external webkitGetGamepads: t => (unit => unit) = "" [@@bs.get];
  external mozGetGamepads: t => (unit => unit) = "" [@@bs.get];
  external mozGamepads: t => 'a = "" [@@bs.get];
  external gamepads: t => 'a = "" [@@bs.get];
  external webkitGamepads: t => 'a = "" [@@bs.get];
  external requestMIDIAccess: t => (unit => unit) = "" [@@bs.get];
  external registerContentHandler: t => (string => string => string => unit) = "" [@@bs.send];
  external registerProtocolHandler: t => (string => string => string => unit) = "" [@@bs.send];
  external requestMediaKeySystemAccess: t => (string => TODO => Promise.t) = "" [@@bs.get];
  external sendBeacon: t => (unit => unit) = "" [@@bs.get];
  external getUserMedia: t => (unit => unit) = "" [@@bs.get];
  external webkitGetUserMedia: t => (unit => unit) = "" [@@bs.get];
  external mozGetUserMedia: t => (unit => unit) = "" [@@bs.get];
  external msGetUserMedia: t => (unit => unit) = "" [@@bs.get];
  external taintEnabled: t => (unit => unit) = "" [@@bs.get];
  external vibrate: t => (TODO => bool) = "" [@@bs.get];
};
let module NavigatorInstance = {
  let appCodeName = "Mozilla";
  external buildID: string = "navigator.buildID" [@@bs.val];
  external cookieEnabled: bool = "navigator.cookieEnabled" [@@bs.val];
  external doNotTrack: 'a = "navigator.doNotTrack" [@@bs.val];
  external geolocation: Geolocation.t = "navigator.geolocation" [@@bs.val];
  external mediaDevices: Object.t = "navigator.mediaDevices" [@@bs.val];
  external javaEnabled: (unit => unit) = "navigator.javaEnabled" [@@bs.val];
  external maxTouchPoints: float = "navigator.maxTouchPoints" [@@bs.val];
  external mimeTypes: MimeTypeArray.t = "navigator.mimeTypes" [@@bs.val];
  external oscpu: string = "navigator.oscpu" [@@bs.val];
  external permissions: 'a = "navigator.permissions" [@@bs.val];
  external plugins: PluginArray.t = "navigator.plugins" [@@bs.val];
  let product = "Gecko";
  external productSub: TODO = "navigator.productSub" [@@bs.val];
  external serviceWorker: Object.t = "navigator.serviceWorker" [@@bs.val];
  external vendor: TODO = "navigator.vendor" [@@bs.val];
  let vendorSub = "";
  external getBattery: (unit => Promise.t) = "navigator.getBattery" [@@bs.val];
  external getGamepads: (unit => TODO) = "navigator.getGamepads" [@@bs.val];
  external webkitGetGamepads: (unit => unit) = "navigator.webkitGetGamepads" [@@bs.val];
  external mozGetGamepads: (unit => unit) = "navigator.mozGetGamepads" [@@bs.val];
  external mozGamepads: 'a = "navigator.mozGamepads" [@@bs.val];
  external gamepads: 'a = "navigator.gamepads" [@@bs.val];
  external webkitGamepads: 'a = "navigator.webkitGamepads" [@@bs.val];
  external requestMIDIAccess: (unit => unit) = "navigator.requestMIDIAccess" [@@bs.val];
  external registerContentHandler: (string => string => string => unit) = "navigator.registerContentHandler" [@@bs.send];
  external registerProtocolHandler: (string => string => string => unit) = "navigator.registerProtocolHandler" [@@bs.send];
  external requestMediaKeySystemAccess: (string => TODO => Promise.t) = "navigator.requestMediaKeySystemAccess" [@@bs.val];
  external sendBeacon: (unit => unit) = "navigator.sendBeacon" [@@bs.val];
  external getUserMedia: (unit => unit) = "navigator.getUserMedia" [@@bs.val];
  external webkitGetUserMedia: (unit => unit) = "navigator.webkitGetUserMedia" [@@bs.val];
  external mozGetUserMedia: (unit => unit) = "navigator.mozGetUserMedia" [@@bs.val];
  external msGetUserMedia: (unit => unit) = "navigator.msGetUserMedia" [@@bs.val];
  external taintEnabled: (unit => unit) = "navigator.taintEnabled" [@@bs.val];
  external vibrate: (TODO => bool) = "navigator.vibrate" [@@bs.val];
};
let module MimeType = {
  type t;
  external create: unit => t = "MimeType" [@@bs.new];
  external _type: t => string = "" [@@bs.get];
  external description: t => string = "" [@@bs.get];
  external suffixes: t => string = "" [@@bs.get];
  external enabledPlugin: t => Plugin.t = "" [@@bs.get];
};
let module MimeTypeArray = {
  type t;
  external create: unit => t = "MimeTypeArray" [@@bs.new];
  external length: t => float = "" [@@bs.get];
  external item: t => (float => MimeType.t) = "" [@@bs.send];
  external namedItem: t => (string => MimeType.t) = "" [@@bs.send];
};
let module Plugin = {
  type t;
  external create: unit => t = "Plugin" [@@bs.new];
  external description: t => string = "" [@@bs.get];
  external filename: t => string = "" [@@bs.get];
  external name: t => string = "" [@@bs.get];
  external version: t => string = "" [@@bs.get];
  external length: t => float = "" [@@bs.get];
  external item: t => (float => MimeType.t) = "" [@@bs.send];
  external namedItem: t => (string => MimeType.t) = "" [@@bs.send];
};
let module PluginArray = {
  type t;
  external create: unit => t = "PluginArray" [@@bs.new];
  external length: t => float = "" [@@bs.get];
  external item: t => (float => Plugin.t) = "" [@@bs.send];
  external namedItem: t => (string => Plugin.t) = "" [@@bs.send];
  external refresh: t => (unit => unit) = "" [@@bs.send];
};
let module PerformanceTiming = {
  type t;
  external create: unit => t = "PerformanceTiming" [@@bs.new];
  external connectEnd: t => float = "" [@@bs.get];
  external connectStart: t => float = "" [@@bs.get];
  external domainLookupEnd: t => float = "" [@@bs.get];
  external domainLookupStart: t => float = "" [@@bs.get];
  external domComplete: t => float = "" [@@bs.get];
  external domContentLoadedEventEnd: t => float = "" [@@bs.get];
  external domContentLoadedEventStart: t => float = "" [@@bs.get];
  external domInteractive: t => float = "" [@@bs.get];
  external domLoading: t => float = "" [@@bs.get];
  external fetchStart: t => float = "" [@@bs.get];
  external loadEventEnd: t => float = "" [@@bs.get];
  external loadEventStart: t => float = "" [@@bs.get];
  external navigationStart: t => float = "" [@@bs.get];
  external redirectEnd: t => float = "" [@@bs.get];
  external redirectStart: t => float = "" [@@bs.get];
  external requestStart: t => float = "" [@@bs.get];
  external responseEnd: t => float = "" [@@bs.get];
  external responseStart: t => float = "" [@@bs.get];
  external secureConnectionStart: t => float = "" [@@bs.get];
  external unloadEventEnd: t => float = "" [@@bs.get];
  external unloadEventStart: t => float = "" [@@bs.get];
};
let module PerformanceNavigation = {
  type t;
  external create: unit => t = "PerformanceNavigation" [@@bs.new];
  let _TYPE_NAVIGATE = 0.;
  let _TYPE_RELOAD = 1.;
  let _TYPE_BACK_FORWARD = 2.;
  let _TYPE_RESERVED = 255.;
  external _type: t => TODO = "" [@@bs.get];
  external redirectCount: t => float = "" [@@bs.get];
};
type TODO;
let module PerformanceEntry = {
  type t;
  external create: unit => t = "PerformanceEntry" [@@bs.new];
  external name: t => string = "" [@@bs.get];
  external entryType: t => string = "" [@@bs.get];
  external startTime: t => float = "" [@@bs.get];
  external duration: t => float = "" [@@bs.get];
  external toJSON: t => (unit => string) = "" [@@bs.send];
};
let module Performance = {
  type t;
  external create: unit => t = "Performance" [@@bs.new];
  external navigation: t => PerformanceNavigation.t = "" [@@bs.get];
  external onresourcetimingbufferfull: t => (Event.t => 'a) = "" [@@bs.get];
  external timing: t => PerformanceTiming.t = "" [@@bs.get];
  external clearMarks: t => (name::(option string) => unit) = "" [@@bs.send];
  external clearMeasures: t => (name::(option string) => unit) = "" [@@bs.send];
  external clearResourceTimings: t => (unit => unit) = "" [@@bs.send];
  external getEntries: t => (options::(option PerformanceEntryFilterOptions.t) => array TODO) = "" [@@bs.send];
  external getEntriesByName: t => (string => type::(option string) => array TODO) = "" [@@bs.send];
  external getEntriesByType: t => (string => array TODO) = "" [@@bs.send];
  external mark: t => (string => unit) = "" [@@bs.send];
  external measure: t => (string => startMark::(option string) => endMark::(option string) => unit) = "" [@@bs.send];
  external now: t => (unit => float) = "" [@@bs.send];
  external setResourceTimingBufferSize: t => (float => unit) = "" [@@bs.send];
  external toJSON: t => (unit => string) = "" [@@bs.send];
};
let module PerformanceInstance = {
  external navigation: PerformanceNavigation.t = "performance.navigation" [@@bs.val];
  external onresourcetimingbufferfull: (Event.t => 'a) = "performance.onresourcetimingbufferfull" [@@bs.val];
  external timing: PerformanceTiming.t = "performance.timing" [@@bs.val];
  external clearMarks: (name::(option string) => unit) = "performance.clearMarks" [@@bs.send];
  external clearMeasures: (name::(option string) => unit) = "performance.clearMeasures" [@@bs.send];
  external clearResourceTimings: (unit => unit) = "performance.clearResourceTimings" [@@bs.send];
  external getEntries: (options::(option PerformanceEntryFilterOptions.t) => array TODO) = "performance.getEntries" [@@bs.send];
  external getEntriesByName: (string => type::(option string) => array TODO) = "performance.getEntriesByName" [@@bs.send];
  external getEntriesByType: (string => array TODO) = "performance.getEntriesByType" [@@bs.send];
  external mark: (string => unit) = "performance.mark" [@@bs.send];
  external measure: (string => startMark::(option string) => endMark::(option string) => unit) = "performance.measure" [@@bs.send];
  external now: (unit => float) = "performance.now" [@@bs.send];
  external setResourceTimingBufferSize: (float => unit) = "performance.setResourceTimingBufferSize" [@@bs.send];
  external toJSON: (unit => string) = "performance.toJSON" [@@bs.send];
};
let module History = {
  type t;
  external create: unit => t = "History" [@@bs.new];
  external length: t => float = "" [@@bs.get];
  external scrollRestoration: t => TODO = "" [@@bs.get];
  external state: t => 'a = "" [@@bs.get];
  external back: t => (unit => unit) = "" [@@bs.send];
  external forward: t => (unit => unit) = "" [@@bs.send];
  external go: t => (delta::(option 'a) => unit) = "" [@@bs.send];
  external pushState: t => ('a => string => url::(option string) => unit) = "" [@@bs.send];
  external replaceState: t => ('a => string => url::(option string) => unit) = "" [@@bs.send];
};
let module HistoryInstance = {
  external length: float = "history.length" [@@bs.val];
  external scrollRestoration: TODO = "history.scrollRestoration" [@@bs.val];
  external state: 'a = "history.state" [@@bs.val];
  external back: (unit => unit) = "history.back" [@@bs.send];
  external forward: (unit => unit) = "history.forward" [@@bs.send];
  external go: (delta::(option 'a) => unit) = "history.go" [@@bs.send];
  external pushState: ('a => string => url::(option string) => unit) = "history.pushState" [@@bs.send];
  external replaceState: ('a => string => url::(option string) => unit) = "history.replaceState" [@@bs.send];
};
let module Location = {
  type t;
  external create: unit => t = "Location" [@@bs.new];
  external ancestorOrigins: t => TODO = "" [@@bs.get];
  external hash: t => string = "" [@@bs.get];
  external host: t => string = "" [@@bs.get];
  external hostname: t => string = "" [@@bs.get];
  external href: t => string = "" [@@bs.get];
  external origin: t => string = "" [@@bs.get];
  external pathname: t => string = "" [@@bs.get];
  external port: t => string = "" [@@bs.get];
  external protocol: t => string = "" [@@bs.get];
  external search: t => string = "" [@@bs.get];
  external assign: t => (string => unit) = "" [@@bs.send];
  external reload: t => (flag::(option bool) => unit) = "" [@@bs.send];
  external replace: t => (string => unit) = "" [@@bs.send];
  external toString: t => (unit => string) = "" [@@bs.send];
};
let module LocationInstance = {
  external ancestorOrigins: TODO = "location.ancestorOrigins" [@@bs.val];
  external hash: string = "location.hash" [@@bs.val];
  external host: string = "location.host" [@@bs.val];
  external hostname: string = "location.hostname" [@@bs.val];
  external href: string = "location.href" [@@bs.val];
  external origin: string = "location.origin" [@@bs.val];
  external pathname: string = "location.pathname" [@@bs.val];
  external port: string = "location.port" [@@bs.val];
  external protocol: string = "location.protocol" [@@bs.val];
  external search: string = "location.search" [@@bs.val];
  external assign: (string => unit) = "location.assign" [@@bs.send];
  external reload: (flag::(option bool) => unit) = "location.reload" [@@bs.send];
  external replace: (string => unit) = "location.replace" [@@bs.send];
  external toString: (unit => string) = "location.toString" [@@bs.send];
};
let module DOMParser = {
  type t;
  external create: unit => t = "DOMParser" [@@bs.new];
  external parseFromString: t => (string => string => Document.t) = "" [@@bs.send];
};
let module FormData = {
  type t;
  external create: unit => t = "FormData" [@@bs.new];
  external append: t => ('a => 'a => blobName::(option string) => unit) = "" [@@bs.send];
};
let module MutationRecord = {
  type t;
  external create: unit => t = "MutationRecord" [@@bs.new];
  external _type: t => TODO = "" [@@bs.get];
  external target: t => Node.t = "" [@@bs.get];
  external addedNodes: t => NodeList.t = "" [@@bs.get];
  external removedNodes: t => NodeList.t = "" [@@bs.get];
  external previousSibling: t => TODO = "" [@@bs.get];
  external nextSibling: t => TODO = "" [@@bs.get];
  external attributeName: t => TODO = "" [@@bs.get];
  external attributeNamespace: t => TODO = "" [@@bs.get];
  external oldValue: t => TODO = "" [@@bs.get];
};
let module MutationObserver = {
  type t;
  external create: unit => t = "MutationObserver" [@@bs.new];
  external constructor: t => ((array TODO => MutationObserver.t => 'a) => unit) = "" [@@bs.send];
  external observe: t => (Node.t => TODO => unit) = "" [@@bs.send];
  external takeRecords: t => (unit => array TODO) = "" [@@bs.send];
  external disconnect: t => (unit => unit) = "" [@@bs.send];
};
let module NodeFilter = {
  external acceptNode: (Node.t => float) = "NodeFilter.acceptNode" [@@bs.send];
  external _SHOW_ENTITY_REFERENCE: float = "NodeFilter.SHOW_ENTITY_REFERENCE" [@@bs.val];
  external _SHOW_NOTATION: float = "NodeFilter.SHOW_NOTATION" [@@bs.val];
  external _SHOW_ENTITY: float = "NodeFilter.SHOW_ENTITY" [@@bs.val];
  external _SHOW_DOCUMENT: float = "NodeFilter.SHOW_DOCUMENT" [@@bs.val];
  external _SHOW_PROCESSING_INSTRUCTION: float = "NodeFilter.SHOW_PROCESSING_INSTRUCTION" [@@bs.val];
  external _FILTER_REJECT: float = "NodeFilter.FILTER_REJECT" [@@bs.val];
  external _SHOW_CDATA_SECTION: float = "NodeFilter.SHOW_CDATA_SECTION" [@@bs.val];
  external _FILTER_ACCEPT: float = "NodeFilter.FILTER_ACCEPT" [@@bs.val];
  external _SHOW_ALL: float = "NodeFilter.SHOW_ALL" [@@bs.val];
  external _SHOW_DOCUMENT_TYPE: float = "NodeFilter.SHOW_DOCUMENT_TYPE" [@@bs.val];
  external _SHOW_TEXT: float = "NodeFilter.SHOW_TEXT" [@@bs.val];
  external _SHOW_ELEMENT: float = "NodeFilter.SHOW_ELEMENT" [@@bs.val];
  external _SHOW_COMMENT: float = "NodeFilter.SHOW_COMMENT" [@@bs.val];
  external _FILTER_SKIP: float = "NodeFilter.FILTER_SKIP" [@@bs.val];
  external _SHOW_ATTRIBUTE: float = "NodeFilter.SHOW_ATTRIBUTE" [@@bs.val];
  external _SHOW_DOCUMENT_FRAGMENT: float = "NodeFilter.SHOW_DOCUMENT_FRAGMENT" [@@bs.val];
};
let module CloseEvent = {
  type t;
  external create: unit => t = "CloseEvent" [@@bs.new];
  external code: t => float = "" [@@bs.get];
  external reason: t => string = "" [@@bs.get];
  external wasClean: t => bool = "" [@@bs.get];
};
let module WebSocket = {
  type t;
  external create: unit => t = "WebSocket" [@@bs.new];
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
  external constructor: t => (string => protocols::(option TODO) => unit) = "" [@@bs.send];
  external protocol: t => string = "" [@@bs.get];
  external readyState: t => float = "" [@@bs.get];
  external bufferedAmount: t => float = "" [@@bs.get];
  external onopen: t => (Event.t => 'a) = "" [@@bs.get];
  external extensions: t => string = "" [@@bs.get];
  external onmessage: t => (MessageEvent.t => 'a) = "" [@@bs.get];
  external onclose: t => (CloseEvent.t => 'a) = "" [@@bs.get];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
  external binaryType: t => string = "" [@@bs.get];
  external url: t => string = "" [@@bs.get];
  external close: t => (code::(option float) => reason::(option string) => unit) = "" [@@bs.send];
  external send: t => ('a => unit) = "" [@@bs.send];
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
};
let module Worker = {
  type t;
  external create: unit => t = "Worker" [@@bs.new];
  external constructor: t => (string => unit) = "" [@@bs.send];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
  external onmessage: t => (MessageEvent.t => 'a) = "" [@@bs.get];
  external postMessage: t => ('a => ports::(option 'a) => unit) = "" [@@bs.send];
  external terminate: t => (unit => unit) = "" [@@bs.send];
};
let module SharedWorker = {
  type t;
  external create: unit => t = "SharedWorker" [@@bs.new];
  external constructor: t => (string => unit) = "" [@@bs.send];
  external port: t => MessagePort.t = "" [@@bs.get];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
};
external importScripts: (array 'rest => unit) = "importScripts" [@@bs.val];
let module WorkerGlobalScope = {
  type t;
  external create: unit => t = "WorkerGlobalScope" [@@bs.new];
  external self: t => WorkerGlobalScope.t = "" [@@bs.get];
  external location: t => WorkerLocation.t = "" [@@bs.get];
  external navigator: t => WorkerNavigator.t = "" [@@bs.get];
  external close: t => (unit => unit) = "" [@@bs.send];
  external importScripts: t => (array 'rest => unit) = "" [@@bs.send] [@@bs.splice];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
  external onlanguagechange: t => (Event.t => 'a) = "" [@@bs.get];
  external onoffline: t => (Event.t => 'a) = "" [@@bs.get];
  external ononline: t => (Event.t => 'a) = "" [@@bs.get];
  external onrejectionhandled: t => (PromiseRejectionEvent.t => 'a) = "" [@@bs.get];
  external onunhandledrejection: t => (PromiseRejectionEvent.t => 'a) = "" [@@bs.get];
};
let module DedicatedWorkerGlobalScope = {
  type t;
  external create: unit => t = "DedicatedWorkerGlobalScope" [@@bs.new];
  external onmessage: t => (unit => (MessageEvent.t => 'a)) = "" [@@bs.send];
  external postMessage: t => ('a => transfer::(option Iterable.t) => unit) = "" [@@bs.send];
};
let module SharedWorkerGlobalScope = {
  type t;
  external create: unit => t = "SharedWorkerGlobalScope" [@@bs.new];
  external name: t => string = "" [@@bs.get];
  external onconnect: t => (MessageEvent.t => 'a) = "" [@@bs.get];
};
let module WorkerLocation = {
  type t;
  external create: unit => t = "WorkerLocation" [@@bs.new];
  external origin: t => string = "" [@@bs.get];
  external protocol: t => string = "" [@@bs.get];
  external host: t => string = "" [@@bs.get];
  external hostname: t => string = "" [@@bs.get];
  external port: t => string = "" [@@bs.get];
  external pathname: t => string = "" [@@bs.get];
  external search: t => string = "" [@@bs.get];
  external hash: t => string = "" [@@bs.get];
};
let module WorkerNavigator = {
  type t;
  external create: unit => t = "WorkerNavigator" [@@bs.new];
};
let module XDomainRequest = {
  type t;
  external create: unit => t = "XDomainRequest" [@@bs.new];
  external timeout: t => float = "" [@@bs.get];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
  external onload: t => (Event.t => 'a) = "" [@@bs.get];
  external onprogress: t => (Event.t => 'a) = "" [@@bs.get];
  external ontimeout: t => (Event.t => 'a) = "" [@@bs.get];
  external responseText: t => string = "" [@@bs.get];
  external contentType: t => string = "" [@@bs.get];
  external open: t => (string => string => unit) = "" [@@bs.send];
  external abort: t => (unit => unit) = "" [@@bs.send];
  external send: t => (data::(option 'a) => unit) = "" [@@bs.send];
  external addEventListener: t => (string => ('a => unit) => useCapture::(option bool) => unit) = "" [@@bs.send];
  let module Statics = {
  external create: (unit => XDomainRequest.t) = "XDomainRequest.statics.create" [@@bs.send];
};
};
let module XMLHttpRequest = {
  type t;
  external create: unit => t = "XMLHttpRequest" [@@bs.new];
  external responseBody: t => 'a = "" [@@bs.get];
  external status: t => float = "" [@@bs.get];
  external readyState: t => float = "" [@@bs.get];
  external responseText: t => string = "" [@@bs.get];
  external responseXML: t => 'a = "" [@@bs.get];
  external ontimeout: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external statusText: t => string = "" [@@bs.get];
  external onreadystatechange: t => (Event.t => 'a) = "" [@@bs.get];
  external timeout: t => float = "" [@@bs.get];
  external onload: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external response: t => 'a = "" [@@bs.get];
  external withCredentials: t => bool = "" [@@bs.get];
  external onprogress: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external onabort: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external responseType: t => string = "" [@@bs.get];
  external onloadend: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external upload: t => XMLHttpRequestEventTarget.t = "" [@@bs.get];
  external onerror: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external onloadstart: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external msCaching: t => string = "" [@@bs.get];
  external open: t => (string => string => async::(option bool) => user::(option string) => password::(option string) => unit) = "" [@@bs.send];
  external send: t => (data::(option 'a) => unit) = "" [@@bs.send];
  external abort: t => (unit => unit) = "" [@@bs.send];
  external getAllResponseHeaders: t => (unit => string) = "" [@@bs.send];
  external setRequestHeader: t => (string => string => unit) = "" [@@bs.send];
  external getResponseHeader: t => (string => string) = "" [@@bs.send];
  external msCachingEnabled: t => (unit => bool) = "" [@@bs.send];
  external overrideMimeType: t => (string => unit) = "" [@@bs.send];
  external _LOADING: t => float = "" [@@bs.get];
  external _DONE: t => float = "" [@@bs.get];
  external _UNSENT: t => float = "" [@@bs.get];
  external _OPENED: t => float = "" [@@bs.get];
  external _HEADERS_RECEIVED: t => float = "" [@@bs.get];
  let module Statics = {
  external create: (unit => XMLHttpRequest.t) = "XMLHttpRequest.statics.create" [@@bs.send];
};
};
let module XMLHttpRequestEventTarget = {
  type t;
  external create: unit => t = "XMLHttpRequestEventTarget" [@@bs.new];
  external onprogress: t => (ProgressEvent.t => 'a) = "" [@@bs.get];
  external onerror: t => (Event.t => 'a) = "" [@@bs.get];
  external onload: t => (Event.t => 'a) = "" [@@bs.get];
  external ontimeout: t => (Event.t => 'a) = "" [@@bs.get];
  external onabort: t => (Event.t => 'a) = "" [@@bs.get];
  external onloadstart: t => (Event.t => 'a) = "" [@@bs.get];
  external onloadend: t => (Event.t => 'a) = "" [@@bs.get];
};
let module XMLSerializer = {
  type t;
  external create: unit => t = "XMLSerializer" [@@bs.new];
  external serializeToString: t => (Node.t => string) = "" [@@bs.send];
};
let module Geolocation = {
  type t;
  external create: unit => t = "Geolocation" [@@bs.new];
  external getCurrentPosition: t => ((Position.t => 'a) => error::(option (PositionError.t => 'a)) => options::(option PositionOptions.t) => 'a) = "" [@@bs.get];
  external watchPosition: t => ((Position.t => 'a) => error::(option (PositionError.t => 'a)) => options::(option PositionOptions.t) => 'a) = "" [@@bs.get];
  external clearWatch: t => 'a = "" [@@bs.get];
};
let module Position = {
  type t;
  external create: unit => t = "Position" [@@bs.new];
  external coords: t => Coordinates.t = "" [@@bs.get];
  external timestamp: t => float = "" [@@bs.get];
};
let module Coordinates = {
  type t;
  external create: unit => t = "Coordinates" [@@bs.new];
  external latitude: t => float = "" [@@bs.get];
  external longitude: t => float = "" [@@bs.get];
  external altitude: t => float = "" [@@bs.get];
  external accuracy: t => float = "" [@@bs.get];
  external altitudeAccuracy: t => float = "" [@@bs.get];
  external heading: t => float = "" [@@bs.get];
};
let module PositionError = {
  type t;
  external create: unit => t = "PositionError" [@@bs.new];
  external code: t => float = "" [@@bs.get];
  external message: t => string = "" [@@bs.get];
  external _PERMISSION_DENIED: t => float = "" [@@bs.get];
  external _POSITION_UNAVAILABLE: t => float = "" [@@bs.get];
  external _TIMEOUT: t => float = "" [@@bs.get];
};
type TODO;
let module AudioContext = {
  type t;
  external create: unit => t = "AudioContext" [@@bs.new];
  external currentTime: t => float = "" [@@bs.get];
  external destination: t => AudioDestinationNode.t = "" [@@bs.get];
  external listener: t => AudioListener.t = "" [@@bs.get];
  external sampleRate: t => float = "" [@@bs.get];
  external state: t => 'a = "" [@@bs.get];
  external onstatechange: t => ('a => 'a) = "" [@@bs.get];
  external close: t => (unit => unit) = "" [@@bs.send];
  external createBuffer: t => (float => float => float => AudioBuffer.t) = "" [@@bs.send];
  external createBufferSource: t => (myMediaElement::(option HTMLMediaElement.t) => AudioBufferSourceNode.t) = "" [@@bs.send];
  external createMediaElementSource: t => (HTMLMediaElement.t => MediaElementAudioSourceNode.t) = "" [@@bs.send];
  external createMediaStreamSource: t => (unit => MediaStreamAudioSourceNode.t) = "" [@@bs.send];
  external createMediaStreamDestination: t => (unit => MediaStream.t) = "" [@@bs.send];
  external createScriptProcessor: t => (float => float => float => ScriptProcessorNode.t) = "" [@@bs.send];
  external createAnalyser: t => (unit => AnalyserNode.t) = "" [@@bs.send];
  external createBiquadFilter: t => (unit => BiquadFilterNode.t) = "" [@@bs.send];
  external createChannelMerger: t => (numberOfInputs::(option float) => ChannelMergerNode.t) = "" [@@bs.send];
  external createChannelSplitter: t => (numberOfInputs::(option float) => ChannelSplitterNode.t) = "" [@@bs.send];
  external createConvolver: t => (unit => ConvolverNode.t) = "" [@@bs.send];
  external createDelay: t => (maxDelayTime::(option float) => DelayNode.t) = "" [@@bs.send];
  external createDynamicCompressor: t => (unit => DynamicsCompressorNode.t) = "" [@@bs.send];
  external createGain: t => (unit => GainNode.t) = "" [@@bs.send];
  external createOscillator: t => (unit => OscillatorNode.t) = "" [@@bs.send];
  external createPanner: t => (unit => PannerNode.t) = "" [@@bs.send];
  external createPeriodicWave: t => (Float32Array.t => Float32Array.t => options::(option TODO) => PeriodicWave.t) = "" [@@bs.send];
  external createWaveShaper: t => (unit => WaveShaperNode.t) = "" [@@bs.send];
  external decodeAudioData: t => (ArrayBuffer.t => (unit => unit) => (unit => unit) => unit) = "" [@@bs.send];
  external decodeAudioData: t => (ArrayBuffer.t => Promise.t) = "" [@@bs.send];
  external resume: t => (unit => Promise.t) = "" [@@bs.send];
  external suspend: t => (unit => Promise.t) = "" [@@bs.send];
};
let module AudioNode = {
  type t;
  external create: unit => t = "AudioNode" [@@bs.new];
  external context: t => AudioContext.t = "" [@@bs.get];
  external numberOfInputs: t => float = "" [@@bs.get];
  external numberOfOutputs: t => float = "" [@@bs.get];
  external channelCount: t => float = "" [@@bs.get];
  external channelCoundMode: t => 'a = "" [@@bs.get];
  external channelInterpretation: t => TODO = "" [@@bs.get];
  external connect: t => (AudioNode.t => output::(option float) => input::(option float) => AudioNode.t) = "" [@@bs.send];
  external connect: t => (AudioParam.t => output::(option float) => unit) = "" [@@bs.send];
  external disconnect: t => (destination::(option AudioNode.t) => output::(option float) => input::(option float) => unit) = "" [@@bs.send];
};
let module AudioParam = {
  type t;
  external create: unit => t = "AudioParam" [@@bs.new];
  external value: t => float = "" [@@bs.get];
  external defaultValue: t => float = "" [@@bs.get];
  external setValueAtTime: t => (float => float => this.t) = "" [@@bs.send];
  external linearRampToValueAtTime: t => (float => float => this.t) = "" [@@bs.send];
  external exponentialRampToValueAtTime: t => (float => float => this.t) = "" [@@bs.send];
  external setTargetAtTime: t => (float => float => float => this.t) = "" [@@bs.send];
  external setValueCurveAtTime: t => (Float32Array.t => float => float => this.t) = "" [@@bs.send];
  external cancelScheduledValues: t => (float => this.t) = "" [@@bs.send];
};
let module AudioDestinationNode = {
  type t;
  external create: unit => t = "AudioDestinationNode" [@@bs.new];
  external maxChannelCount: t => float = "" [@@bs.get];
};
let module AudioListener = {
  type t;
  external create: unit => t = "AudioListener" [@@bs.new];
  external setOrientation: t => (float => float => float => float => float => float => unit) = "" [@@bs.send];
};
let module AudioBuffer = {
  type t;
  external create: unit => t = "AudioBuffer" [@@bs.new];
  external sampleRate: t => float = "" [@@bs.get];
  external length: t => float = "" [@@bs.get];
  external duration: t => float = "" [@@bs.get];
  external numberOfChannels: t => float = "" [@@bs.get];
  external getChannelData: t => (float => Float32Array.t) = "" [@@bs.send];
  external copyFromChannel: t => (Float32Array.t => float => startInChannel::(option float) => unit) = "" [@@bs.send];
  external copyToChannel: t => (Float32Array.t => float => startInChannel::(option float) => unit) = "" [@@bs.send];
};
let module AudioBufferSourceNode = {
  type t;
  external create: unit => t = "AudioBufferSourceNode" [@@bs.new];
  external buffer: t => AudioBuffer.t = "" [@@bs.get];
  external detune: t => AudioParam.t = "" [@@bs.get];
  external loop: t => bool = "" [@@bs.get];
  external loopStart: t => float = "" [@@bs.get];
  external loopEnd: t => float = "" [@@bs.get];
  external playbackRate: t => AudioParam.t = "" [@@bs.get];
  external onended: t => ('a => 'a) = "" [@@bs.get];
  external start: t => (when::(option float) => offset::(option float) => duration::(option float) => unit) = "" [@@bs.send];
  external stop: t => (when::(option float) => unit) = "" [@@bs.send];
};
let module MediaStream = {
  type t;
  external create: unit => t = "MediaStream" [@@bs.new];
  external active: t => bool = "" [@@bs.get];
  external ended: t => bool = "" [@@bs.get];
  external id: t => string = "" [@@bs.get];
  external onactive: t => ('a => 'a) = "" [@@bs.get];
  external onaddtrack: t => ('a => 'a) = "" [@@bs.get];
  external onended: t => ('a => 'a) = "" [@@bs.get];
  external oninactive: t => ('a => 'a) = "" [@@bs.get];
  external onremovetrack: t => ('a => 'a) = "" [@@bs.get];
  external addTrack: t => (MediaStreamTrack.t => unit) = "" [@@bs.send];
  external clone: t => (unit => MediaStream.t) = "" [@@bs.send];
  external getAudioTracks: t => (unit => TODO) = "" [@@bs.send];
  external getTrackById: t => (trackid::(option string) => TODO) = "" [@@bs.send];
  external getTracks: t => (unit => TODO) = "" [@@bs.send];
  external getVideoTracks: t => (unit => TODO) = "" [@@bs.send];
  external removeTrack: t => (MediaStreamTrack.t => unit) = "" [@@bs.send];
};
let module MediaStreamTrack = {
  type t;
  external create: unit => t = "MediaStreamTrack" [@@bs.new];
  external enabled: t => bool = "" [@@bs.get];
  external id: t => string = "" [@@bs.get];
  external kind: t => string = "" [@@bs.get];
  external label: t => string = "" [@@bs.get];
  external muted: t => bool = "" [@@bs.get];
  external readonly: t => bool = "" [@@bs.get];
  external readyState: t => TODO = "" [@@bs.get];
  external remote: t => bool = "" [@@bs.get];
  external onstarted: t => ('a => 'a) = "" [@@bs.get];
  external onmute: t => ('a => 'a) = "" [@@bs.get];
  external onunmute: t => ('a => 'a) = "" [@@bs.get];
  external onoverconstrained: t => ('a => 'a) = "" [@@bs.get];
  external onended: t => ('a => 'a) = "" [@@bs.get];
  external getConstraints: t => (unit => 'a) = "" [@@bs.send];
  external applyConstraints: t => (unit => 'a) = "" [@@bs.send];
  external getSettings: t => (unit => 'a) = "" [@@bs.send];
  external getCapabilities: t => (unit => 'a) = "" [@@bs.send];
  external clone: t => (unit => MediaStreamTrack.t) = "" [@@bs.send];
  external stop: t => (unit => unit) = "" [@@bs.send];
};
let module MediaElementAudioSourceNode = {
  type t;
  external create: unit => t = "MediaElementAudioSourceNode" [@@bs.new];
};
let module MediaStreamAudioSourceNode = {
  type t;
  external create: unit => t = "MediaStreamAudioSourceNode" [@@bs.new];
};
let module ScriptProcessorNode = {
  type t;
  external create: unit => t = "ScriptProcessorNode" [@@bs.new];
  external bufferSize: t => float = "" [@@bs.get];
  external onaudioprocess: t => ('a => 'a) = "" [@@bs.get];
};
let module AnalyserNode = {
  type t;
  external create: unit => t = "AnalyserNode" [@@bs.new];
  external fftSize: t => float = "" [@@bs.get];
  external frequencyBinCount: t => float = "" [@@bs.get];
  external minDecibels: t => float = "" [@@bs.get];
  external maxDecibels: t => float = "" [@@bs.get];
  external smoothingTimeConstant: t => float = "" [@@bs.get];
  external getFloatFrequencyData: t => (Float32Array.t => Float32Array.t) = "" [@@bs.send];
  external getByteFrequencyData: t => (Uint8Array.t => Uint8Array.t) = "" [@@bs.send];
  external getFloatTimeDomainData: t => (Float32Array.t => Float32Array.t) = "" [@@bs.send];
  external getByteTimeDomainData: t => (Uint8Array.t => Uint8Array.t) = "" [@@bs.send];
};
let module BiquadFilterNode = {
  type t;
  external create: unit => t = "BiquadFilterNode" [@@bs.new];
  external frequency: t => AudioParam.t = "" [@@bs.get];
  external detune: t => AudioParam.t = "" [@@bs.get];
  external _Q: t => AudioParam.t = "" [@@bs.get];
  external gain: t => AudioParam.t = "" [@@bs.get];
  external _type: t => TODO = "" [@@bs.get];
  external getFrequencyResponse: t => (Float32Array.t => Float32Array.t => Float32Array.t => BiquadFilterNode.t) = "" [@@bs.send];
};
let module ChannelMergerNode = {
  type t;
  external create: unit => t = "ChannelMergerNode" [@@bs.new];
};
let module ChannelSplitterNode = {
  type t;
  external create: unit => t = "ChannelSplitterNode" [@@bs.new];
};
let module ConvolverNode = {
  type t;
  external create: unit => t = "ConvolverNode" [@@bs.new];
  external buffer: t => AudioBuffer.t = "" [@@bs.get];
  external normalize: t => bool = "" [@@bs.get];
};
let module DelayNode = {
  type t;
  external create: unit => t = "DelayNode" [@@bs.new];
  external delayTime: t => float = "" [@@bs.get];
};
let module DynamicsCompressorNode = {
  type t;
  external create: unit => t = "DynamicsCompressorNode" [@@bs.new];
  external threshold: t => AudioParam.t = "" [@@bs.get];
  external knee: t => AudioParam.t = "" [@@bs.get];
  external ratio: t => AudioParam.t = "" [@@bs.get];
  external reduction: t => AudioParam.t = "" [@@bs.get];
  external attack: t => AudioParam.t = "" [@@bs.get];
  external release: t => AudioParam.t = "" [@@bs.get];
};
let module GainNode = {
  type t;
  external create: unit => t = "GainNode" [@@bs.new];
  external gain: t => AudioParam.t = "" [@@bs.get];
};
let module OscillatorNode = {
  type t;
  external create: unit => t = "OscillatorNode" [@@bs.new];
  external frequency: t => AudioParam.t = "" [@@bs.get];
  external detune: t => AudioParam.t = "" [@@bs.get];
  external _type: t => TODO = "" [@@bs.get];
  external start: t => (when::(option float) => unit) = "" [@@bs.send];
  external stop: t => (when::(option float) => unit) = "" [@@bs.send];
  external setPeriodicWave: t => (PeriodicWave.t => unit) = "" [@@bs.send];
};
let module PannerNode = {
  type t;
  external create: unit => t = "PannerNode" [@@bs.new];
  external panningModel: t => TODO = "" [@@bs.get];
  external distanceModel: t => TODO = "" [@@bs.get];
  external refDistance: t => float = "" [@@bs.get];
  external maxDistance: t => float = "" [@@bs.get];
  external rollofFactor: t => float = "" [@@bs.get];
  external coneInnerAngle: t => float = "" [@@bs.get];
  external coneOuterAngle: t => float = "" [@@bs.get];
  external coneOuterGain: t => float = "" [@@bs.get];
  external setPosition: t => (float => float => float => unit) = "" [@@bs.send];
  external setOrientation: t => (float => float => float => unit) = "" [@@bs.send];
};
let module PeriodicWave = {
  type t;
  external create: unit => t = "PeriodicWave" [@@bs.new];
};
let module WaveShaperNode = {
  type t;
  external create: unit => t = "WaveShaperNode" [@@bs.new];
  external curve: t => Float32Array.t = "" [@@bs.get];
  external oversample: t => TODO = "" [@@bs.get];
};
let module AudioContextInstance = {
  external currentTime: float = "AudioContext.currentTime" [@@bs.val];
  external destination: AudioDestinationNode.t = "AudioContext.destination" [@@bs.val];
  external listener: AudioListener.t = "AudioContext.listener" [@@bs.val];
  external sampleRate: float = "AudioContext.sampleRate" [@@bs.val];
  external state: 'a = "AudioContext.state" [@@bs.val];
  external onstatechange: ('a => 'a) = "AudioContext.onstatechange" [@@bs.val];
  external close: (unit => unit) = "AudioContext.close" [@@bs.send];
  external createBuffer: (float => float => float => AudioBuffer.t) = "AudioContext.createBuffer" [@@bs.send];
  external createBufferSource: (myMediaElement::(option HTMLMediaElement.t) => AudioBufferSourceNode.t) = "AudioContext.createBufferSource" [@@bs.send];
  external createMediaElementSource: (HTMLMediaElement.t => MediaElementAudioSourceNode.t) = "AudioContext.createMediaElementSource" [@@bs.send];
  external createMediaStreamSource: (unit => MediaStreamAudioSourceNode.t) = "AudioContext.createMediaStreamSource" [@@bs.send];
  external createMediaStreamDestination: (unit => MediaStream.t) = "AudioContext.createMediaStreamDestination" [@@bs.send];
  external createScriptProcessor: (float => float => float => ScriptProcessorNode.t) = "AudioContext.createScriptProcessor" [@@bs.send];
  external createAnalyser: (unit => AnalyserNode.t) = "AudioContext.createAnalyser" [@@bs.send];
  external createBiquadFilter: (unit => BiquadFilterNode.t) = "AudioContext.createBiquadFilter" [@@bs.send];
  external createChannelMerger: (numberOfInputs::(option float) => ChannelMergerNode.t) = "AudioContext.createChannelMerger" [@@bs.send];
  external createChannelSplitter: (numberOfInputs::(option float) => ChannelSplitterNode.t) = "AudioContext.createChannelSplitter" [@@bs.send];
  external createConvolver: (unit => ConvolverNode.t) = "AudioContext.createConvolver" [@@bs.send];
  external createDelay: (maxDelayTime::(option float) => DelayNode.t) = "AudioContext.createDelay" [@@bs.send];
  external createDynamicCompressor: (unit => DynamicsCompressorNode.t) = "AudioContext.createDynamicCompressor" [@@bs.send];
  external createGain: (unit => GainNode.t) = "AudioContext.createGain" [@@bs.send];
  external createOscillator: (unit => OscillatorNode.t) = "AudioContext.createOscillator" [@@bs.send];
  external createPanner: (unit => PannerNode.t) = "AudioContext.createPanner" [@@bs.send];
  external createPeriodicWave: (Float32Array.t => Float32Array.t => options::(option TODO) => PeriodicWave.t) = "AudioContext.createPeriodicWave" [@@bs.send];
  external createWaveShaper: (unit => WaveShaperNode.t) = "AudioContext.createWaveShaper" [@@bs.send];
  external decodeAudioData: (ArrayBuffer.t => (unit => unit) => (unit => unit) => unit) = "AudioContext.decodeAudioData" [@@bs.send];
  external decodeAudioData: (ArrayBuffer.t => Promise.t) = "AudioContext.decodeAudioData" [@@bs.send];
  external resume: (unit => Promise.t) = "AudioContext.resume" [@@bs.send];
  external suspend: (unit => Promise.t) = "AudioContext.suspend" [@@bs.send];
};
type TODO;
let module Headers = {
  type t;
  external create: unit => t = "Headers" [@@bs.new];
  external _@@iterator: t => (unit => Iterator.t) = "" [@@bs.send];
  external constructor: t => (init::(option HeadersInit.t) => unit) = "" [@@bs.send];
  external append: t => (string => string => unit) = "" [@@bs.send];
  external delete: t => (string => unit) = "" [@@bs.send];
  external entries: t => (unit => Iterator.t) = "" [@@bs.send];
  external get: t => (string => string) = "" [@@bs.send];
  external getAll: t => (string => array string) = "" [@@bs.send];
  external has: t => (string => bool) = "" [@@bs.send];
  external keys: t => (unit => Iterator.t) = "" [@@bs.send];
  external set: t => (string => string => unit) = "" [@@bs.send];
  external values: t => (unit => Iterator.t) = "" [@@bs.send];
};
let module URLSearchParams = {
  type t;
  external create: unit => t = "URLSearchParams" [@@bs.new];
  external _@@iterator: t => (unit => Iterator.t) = "" [@@bs.send];
  external constructor: t => (query::(option TODO) => unit) = "" [@@bs.send];
  external append: t => (string => string => unit) = "" [@@bs.send];
  external delete: t => (string => unit) = "" [@@bs.send];
  external entries: t => (unit => Iterator.t) = "" [@@bs.send];
  external get: t => (string => string) = "" [@@bs.send];
  external getAll: t => (string => array string) = "" [@@bs.send];
  external has: t => (string => bool) = "" [@@bs.send];
  external keys: t => (unit => Iterator.t) = "" [@@bs.send];
  external set: t => (string => string => unit) = "" [@@bs.send];
  external values: t => (unit => Iterator.t) = "" [@@bs.send];
};
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
let module Response = {
  type t;
  external create: unit => t = "Response" [@@bs.new];
  external constructor: t => (input::(option TODO) => init::(option ResponseOptions.t) => unit) = "" [@@bs.send];
  external clone: t => (unit => Response.t) = "" [@@bs.send];
  external error: (unit => Response.t) = "" [@@bs.val];
  external redirect: (string => float => Response.t) = "" [@@bs.val];
  external _type: t => ResponseType.t = "" [@@bs.get];
  external url: t => string = "" [@@bs.get];
  external useFinalURL: t => bool = "" [@@bs.get];
  external ok: t => bool = "" [@@bs.get];
  external status: t => float = "" [@@bs.get];
  external statusText: t => string = "" [@@bs.get];
  external headers: t => Headers.t = "" [@@bs.get];
  external bodyUsed: t => bool = "" [@@bs.get];
  external arrayBuffer: t => (unit => Promise.t) = "" [@@bs.send];
  external blob: t => (unit => Promise.t) = "" [@@bs.send];
  external formData: t => (unit => Promise.t) = "" [@@bs.send];
  external json: t => (unit => Promise.t) = "" [@@bs.send];
  external text: t => (unit => Promise.t) = "" [@@bs.send];
};
let module Request = {
  type t;
  external create: unit => t = "Request" [@@bs.new];
  external constructor: t => (TODO => init::(option RequestOptions.t) => unit) = "" [@@bs.send];
  external clone: t => (unit => Request.t) = "" [@@bs.send];
  external url: t => string = "" [@@bs.get];
  external cache: t => CacheType.t = "" [@@bs.get];
  external credentials: t => CredentialsType.t = "" [@@bs.get];
  external headers: t => Headers.t = "" [@@bs.get];
  external integrity: t => string = "" [@@bs.get];
  external method: t => MethodType.t = "" [@@bs.get];
  external mode: t => ModeType.t = "" [@@bs.get];
  external redirect: t => RedirectType.t = "" [@@bs.get];
  external referrer: t => string = "" [@@bs.get];
  external referrerPolicy: t => ReferrerPolicyType.t = "" [@@bs.get];
  external bodyUsed: t => bool = "" [@@bs.get];
  external arrayBuffer: t => (unit => Promise.t) = "" [@@bs.send];
  external blob: t => (unit => Promise.t) = "" [@@bs.send];
  external formData: t => (unit => Promise.t) = "" [@@bs.send];
  external json: t => (unit => Promise.t) = "" [@@bs.send];
  external text: t => (unit => Promise.t) = "" [@@bs.send];
};
external fetch: (string => init::(option RequestOptions.t) => Promise.t) = "fetch" [@@bs.val];
let module MessagePort = {
  type t;
  external create: unit => t = "MessagePort" [@@bs.new];
  external postMessage: t => ('a => transfer::(option Iterable.t) => unit) = "" [@@bs.send];
  external start: t => (unit => unit) = "" [@@bs.send];
  external close: t => (unit => unit) = "" [@@bs.send];
  external onmessage: t => (Event.t => 'a) = "" [@@bs.get];
};
let module MessageChannel = {
  type t;
  external create: unit => t = "MessageChannel" [@@bs.new];
  external port1: t => MessagePort.t = "" [@@bs.get];
  external port2: t => MessagePort.t = "" [@@bs.get];
};
