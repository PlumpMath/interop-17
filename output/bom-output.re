let module Screen = {
  type t;
  external availHeight: float = "" [@@bs.get];
  external availLeft: float = "" [@@bs.get];
  external availTop: float = "" [@@bs.get];
  external availWidth: float = "" [@@bs.get];
  external colorDepth: float = "" [@@bs.get];
  external height: float = "" [@@bs.get];
  external left: float = "" [@@bs.get];
  external mozOrientation: string = "" [@@bs.get];
  external onmozorientationchange: 'a = "" [@@bs.get];
  external orientation: TODO = "" [@@bs.get];
  external pixelDepth: float = "" [@@bs.get];
  external top: float = "" [@@bs.get];
  external width: float = "" [@@bs.get];
  external mozLockOrientation: (unit => unit) = "" [@@bs.get];
  external mozUnlockOrientation: (unit => unit) = "" [@@bs.get];
  external mozOrientation: string = "" [@@bs.get];
  external onmozorientationchange: (unit => unit) = "" [@@bs.get];
};
let module ScreenInstance = {
  external availHeight: float = "screen.availHeight" [@@bs.val];
  external availLeft: float = "screen.availLeft" [@@bs.val];
  external availTop: float = "screen.availTop" [@@bs.val];
  external availWidth: float = "screen.availWidth" [@@bs.val];
  external colorDepth: float = "screen.colorDepth" [@@bs.val];
  external height: float = "screen.height" [@@bs.val];
  external left: float = "screen.left" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: 'a = "screen.onmozorientationchange" [@@bs.val];
  external orientation: TODO = "screen.orientation" [@@bs.val];
  external pixelDepth: float = "screen.pixelDepth" [@@bs.val];
  external top: float = "screen.top" [@@bs.val];
  external width: float = "screen.width" [@@bs.val];
  external mozLockOrientation: (unit => unit) = "screen.mozLockOrientation" [@@bs.val];
  external mozUnlockOrientation: (unit => unit) = "screen.mozUnlockOrientation" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: (unit => unit) = "screen.onmozorientationchange" [@@bs.val];
};
external window: 'a = "window" [@@bs.val];
type TODO;
type TODO;
let module NavigatorCommon = {
  type t;
  let appName = "Netscape";
  external appVersion: string = "" [@@bs.get];
  external platform: string = "" [@@bs.get];
  external userAgent: string = "" [@@bs.get];
  external language: string = "" [@@bs.get];
  external languages: Array = "" [@@bs.get];
  external onLine: bool = "" [@@bs.get];
  external hardwareConcurrency: float = "" [@@bs.get];
};
let module Navigator = {
  type t;
  let appCodeName = "Mozilla";
  external buildID: string = "" [@@bs.get];
  external cookieEnabled: bool = "" [@@bs.get];
  external doNotTrack: 'a = "" [@@bs.get];
  external geolocation: Geolocation = "" [@@bs.get];
  external mediaDevices: Object = "" [@@bs.get];
  external javaEnabled: (unit => unit) = "" [@@bs.get];
  external maxTouchPoints: float = "" [@@bs.get];
  external mimeTypes: MimeTypeArray = "" [@@bs.get];
  external oscpu: string = "" [@@bs.get];
  external permissions: 'a = "" [@@bs.get];
  external plugins: PluginArray = "" [@@bs.get];
  let product = "Gecko";
  external productSub: TODO = "" [@@bs.get];
  external serviceWorker: Object = "" [@@bs.get];
  external vendor: TODO = "" [@@bs.get];
  let vendorSub = "";
  external getBattery: unit => Promise = "" [@@bs.get];
  external getGamepads: unit => TODO = "" [@@bs.get];
  external webkitGetGamepads: (unit => unit) = "" [@@bs.get];
  external mozGetGamepads: (unit => unit) = "" [@@bs.get];
  external mozGamepads: 'a = "" [@@bs.get];
  external gamepads: 'a = "" [@@bs.get];
  external webkitGamepads: 'a = "" [@@bs.get];
  external requestMIDIAccess: (unit => unit) = "" [@@bs.get];
  external registerContentHandler: t => string => string => string => unit = "" [@@bs.send];
  external registerProtocolHandler: t => string => string => string => unit = "" [@@bs.send];
  external requestMediaKeySystemAccess: string => TODO => Promise = "" [@@bs.get];
  external sendBeacon: (unit => unit) = "" [@@bs.get];
  external getUserMedia: (unit => unit) = "" [@@bs.get];
  external webkitGetUserMedia: (unit => unit) = "" [@@bs.get];
  external mozGetUserMedia: (unit => unit) = "" [@@bs.get];
  external msGetUserMedia: (unit => unit) = "" [@@bs.get];
  external taintEnabled: (unit => unit) = "" [@@bs.get];
  external vibrate: TODO => bool = "" [@@bs.get];
};
let module NavigatorInstance = {
  let appCodeName = "Mozilla";
  external buildID: string = "navigator.buildID" [@@bs.val];
  external cookieEnabled: bool = "navigator.cookieEnabled" [@@bs.val];
  external doNotTrack: 'a = "navigator.doNotTrack" [@@bs.val];
  external geolocation: Geolocation = "navigator.geolocation" [@@bs.val];
  external mediaDevices: Object = "navigator.mediaDevices" [@@bs.val];
  external javaEnabled: (unit => unit) = "navigator.javaEnabled" [@@bs.val];
  external maxTouchPoints: float = "navigator.maxTouchPoints" [@@bs.val];
  external mimeTypes: MimeTypeArray = "navigator.mimeTypes" [@@bs.val];
  external oscpu: string = "navigator.oscpu" [@@bs.val];
  external permissions: 'a = "navigator.permissions" [@@bs.val];
  external plugins: PluginArray = "navigator.plugins" [@@bs.val];
  let product = "Gecko";
  external productSub: TODO = "navigator.productSub" [@@bs.val];
  external serviceWorker: Object = "navigator.serviceWorker" [@@bs.val];
  external vendor: TODO = "navigator.vendor" [@@bs.val];
  let vendorSub = "";
  external getBattery: unit => Promise = "navigator.getBattery" [@@bs.val];
  external getGamepads: unit => TODO = "navigator.getGamepads" [@@bs.val];
  external webkitGetGamepads: (unit => unit) = "navigator.webkitGetGamepads" [@@bs.val];
  external mozGetGamepads: (unit => unit) = "navigator.mozGetGamepads" [@@bs.val];
  external mozGamepads: 'a = "navigator.mozGamepads" [@@bs.val];
  external gamepads: 'a = "navigator.gamepads" [@@bs.val];
  external webkitGamepads: 'a = "navigator.webkitGamepads" [@@bs.val];
  external requestMIDIAccess: (unit => unit) = "navigator.requestMIDIAccess" [@@bs.val];
  external registerContentHandler: string => string => string => unit = "navigator.registerContentHandler" [@@bs.val];
  external registerProtocolHandler: string => string => string => unit = "navigator.registerProtocolHandler" [@@bs.val];
  external requestMediaKeySystemAccess: string => TODO => Promise = "navigator.requestMediaKeySystemAccess" [@@bs.val];
  external sendBeacon: (unit => unit) = "navigator.sendBeacon" [@@bs.val];
  external getUserMedia: (unit => unit) = "navigator.getUserMedia" [@@bs.val];
  external webkitGetUserMedia: (unit => unit) = "navigator.webkitGetUserMedia" [@@bs.val];
  external mozGetUserMedia: (unit => unit) = "navigator.mozGetUserMedia" [@@bs.val];
  external msGetUserMedia: (unit => unit) = "navigator.msGetUserMedia" [@@bs.val];
  external taintEnabled: (unit => unit) = "navigator.taintEnabled" [@@bs.val];
  external vibrate: TODO => bool = "navigator.vibrate" [@@bs.val];
};
let module MimeType = {
  type t;
  external _type: string = "" [@@bs.get];
  external description: string = "" [@@bs.get];
  external suffixes: string = "" [@@bs.get];
  external enabledPlugin: Plugin = "" [@@bs.get];
};
let module MimeTypeArray = {
  type t;
  external length: float = "" [@@bs.get];
  external item: t => float => MimeType = "" [@@bs.send];
  external namedItem: t => string => MimeType = "" [@@bs.send];
};
let module Plugin = {
  type t;
  external description: string = "" [@@bs.get];
  external filename: string = "" [@@bs.get];
  external name: string = "" [@@bs.get];
  external version: string = "" [@@bs.get];
  external length: float = "" [@@bs.get];
  external item: t => float => MimeType = "" [@@bs.send];
  external namedItem: t => string => MimeType = "" [@@bs.send];
};
let module PluginArray = {
  type t;
  external length: float = "" [@@bs.get];
  external item: t => float => Plugin = "" [@@bs.send];
  external namedItem: t => string => Plugin = "" [@@bs.send];
  external refresh: t => unit => unit = "" [@@bs.send];
};
let module PerformanceTiming = {
  type t;
  external connectEnd: float = "" [@@bs.get];
  external connectStart: float = "" [@@bs.get];
  external domainLookupEnd: float = "" [@@bs.get];
  external domainLookupStart: float = "" [@@bs.get];
  external domComplete: float = "" [@@bs.get];
  external domContentLoadedEventEnd: float = "" [@@bs.get];
  external domContentLoadedEventStart: float = "" [@@bs.get];
  external domInteractive: float = "" [@@bs.get];
  external domLoading: float = "" [@@bs.get];
  external fetchStart: float = "" [@@bs.get];
  external loadEventEnd: float = "" [@@bs.get];
  external loadEventStart: float = "" [@@bs.get];
  external navigationStart: float = "" [@@bs.get];
  external redirectEnd: float = "" [@@bs.get];
  external redirectStart: float = "" [@@bs.get];
  external requestStart: float = "" [@@bs.get];
  external responseEnd: float = "" [@@bs.get];
  external responseStart: float = "" [@@bs.get];
  external secureConnectionStart: float = "" [@@bs.get];
  external unloadEventEnd: float = "" [@@bs.get];
  external unloadEventStart: float = "" [@@bs.get];
};
let module PerformanceNavigation = {
  type t;
  let _TYPE_NAVIGATE = 0.;
  let _TYPE_RELOAD = 1.;
  let _TYPE_BACK_FORWARD = 2.;
  let _TYPE_RESERVED = 255.;
  external _type: TODO = "" [@@bs.get];
  external redirectCount: float = "" [@@bs.get];
};
type TODO;
let module PerformanceEntry = {
  type t;
  external name: string = "" [@@bs.get];
  external entryType: string = "" [@@bs.get];
  external startTime: float = "" [@@bs.get];
  external duration: float = "" [@@bs.get];
  external toJSON: t => unit => string = "" [@@bs.send];
};
let module Performance = {
  type t;
  external navigation: PerformanceNavigation = "" [@@bs.get];
  external onresourcetimingbufferfull: Event => 'a = "" [@@bs.get];
  external timing: PerformanceTiming = "" [@@bs.get];
  external clearMarks: t => name::(option string) => unit = "" [@@bs.send];
  external clearMeasures: t => name::(option string) => unit = "" [@@bs.send];
  external clearResourceTimings: t => unit => unit = "" [@@bs.send];
  external getEntries: t => options::(option PerformanceEntryFilterOptions) => Array = "" [@@bs.send];
  external getEntriesByName: t => string => type::(option string) => Array = "" [@@bs.send];
  external getEntriesByType: t => string => Array = "" [@@bs.send];
  external mark: t => string => unit = "" [@@bs.send];
  external measure: t => string => startMark::(option string) => endMark::(option string) => unit = "" [@@bs.send];
  external now: t => unit => float = "" [@@bs.send];
  external setResourceTimingBufferSize: t => float => unit = "" [@@bs.send];
  external toJSON: t => unit => string = "" [@@bs.send];
};
let module PerformanceInstance = {
  external navigation: PerformanceNavigation = "performance.navigation" [@@bs.val];
  external onresourcetimingbufferfull: Event => 'a = "performance.onresourcetimingbufferfull" [@@bs.val];
  external timing: PerformanceTiming = "performance.timing" [@@bs.val];
  external clearMarks: name::(option string) => unit = "performance.clearMarks" [@@bs.val];
  external clearMeasures: name::(option string) => unit = "performance.clearMeasures" [@@bs.val];
  external clearResourceTimings: unit => unit = "performance.clearResourceTimings" [@@bs.val];
  external getEntries: options::(option PerformanceEntryFilterOptions) => Array = "performance.getEntries" [@@bs.val];
  external getEntriesByName: string => type::(option string) => Array = "performance.getEntriesByName" [@@bs.val];
  external getEntriesByType: string => Array = "performance.getEntriesByType" [@@bs.val];
  external mark: string => unit = "performance.mark" [@@bs.val];
  external measure: string => startMark::(option string) => endMark::(option string) => unit = "performance.measure" [@@bs.val];
  external now: unit => float = "performance.now" [@@bs.val];
  external setResourceTimingBufferSize: float => unit = "performance.setResourceTimingBufferSize" [@@bs.val];
  external toJSON: unit => string = "performance.toJSON" [@@bs.val];
};
let module History = {
  type t;
  external length: float = "" [@@bs.get];
  external scrollRestoration: TODO = "" [@@bs.get];
  external state: 'a = "" [@@bs.get];
  external back: t => unit => unit = "" [@@bs.send];
  external forward: t => unit => unit = "" [@@bs.send];
  external go: t => delta::(option 'a) => unit = "" [@@bs.send];
  external pushState: t => 'a => string => url::(option string) => unit = "" [@@bs.send];
  external replaceState: t => 'a => string => url::(option string) => unit = "" [@@bs.send];
};
let module HistoryInstance = {
  external length: float = "history.length" [@@bs.val];
  external scrollRestoration: TODO = "history.scrollRestoration" [@@bs.val];
  external state: 'a = "history.state" [@@bs.val];
  external back: unit => unit = "history.back" [@@bs.val];
  external forward: unit => unit = "history.forward" [@@bs.val];
  external go: delta::(option 'a) => unit = "history.go" [@@bs.val];
  external pushState: 'a => string => url::(option string) => unit = "history.pushState" [@@bs.val];
  external replaceState: 'a => string => url::(option string) => unit = "history.replaceState" [@@bs.val];
};
let module Location = {
  type t;
  external ancestorOrigins: TODO = "" [@@bs.get];
  external hash: string = "" [@@bs.get];
  external host: string = "" [@@bs.get];
  external hostname: string = "" [@@bs.get];
  external href: string = "" [@@bs.get];
  external origin: string = "" [@@bs.get];
  external pathname: string = "" [@@bs.get];
  external port: string = "" [@@bs.get];
  external protocol: string = "" [@@bs.get];
  external search: string = "" [@@bs.get];
  external assign: t => string => unit = "" [@@bs.send];
  external reload: t => flag::(option bool) => unit = "" [@@bs.send];
  external replace: t => string => unit = "" [@@bs.send];
  external toString: t => unit => string = "" [@@bs.send];
};
let module LocationInstance = {
  external ancestorOrigins: TODO = "location.ancestorOrigins" [@@bs.val];
  external hash: string = "location.hash" [@@bs.val];
  external host: string = "location.host" [@@bs.val];
  external hostname: string = "location.hostname" [@@bs.val];
  external href: string = "location.href" [@@bs.val];
  external origin: string = "location.origin" [@@bs.val];
  external pathname: string = "location.pathname" [@@bs.val];
  external port: string = "location.port" [@@bs.val];
  external protocol: string = "location.protocol" [@@bs.val];
  external search: string = "location.search" [@@bs.val];
  external assign: string => unit = "location.assign" [@@bs.val];
  external reload: flag::(option bool) => unit = "location.reload" [@@bs.val];
  external replace: string => unit = "location.replace" [@@bs.val];
  external toString: unit => string = "location.toString" [@@bs.val];
};
let module DOMParser = {
  type t;
  external parseFromString: t => string => string => Document = "" [@@bs.send];
};
let module FormData = {
  type t;
  external append: t => 'a => 'a => blobName::(option string) => unit = "" [@@bs.send];
};
let module MutationRecord = {
  type t;
  external _type: TODO = "" [@@bs.get];
  external target: Node = "" [@@bs.get];
  external addedNodes: NodeList = "" [@@bs.get];
  external removedNodes: NodeList = "" [@@bs.get];
  external previousSibling: TODO = "" [@@bs.get];
  external nextSibling: TODO = "" [@@bs.get];
  external attributeName: TODO = "" [@@bs.get];
  external attributeNamespace: TODO = "" [@@bs.get];
  external oldValue: TODO = "" [@@bs.get];
};
let module MutationObserver = {
  type t;
  external constructor: t => Array => MutationObserver => 'a => unit = "" [@@bs.send];
  external observe: t => Node => TODO => unit = "" [@@bs.send];
  external takeRecords: t => unit => Array = "" [@@bs.send];
  external disconnect: t => unit => unit = "" [@@bs.send];
};
let module NodeFilter = {
  external acceptNode: Node => float = "NodeFilter.acceptNode" [@@bs.val];
  external _SHOW_ENTITY_REFERENCE: float = "NodeFilter.SHOW_ENTITY_REFERENCE" [@@bs.val];
  external _SHOW_NOTATION: float = "NodeFilter.SHOW_NOTATION" [@@bs.val];
  external _SHOW_ENTITY: float = "NodeFilter.SHOW_ENTITY" [@@bs.val];
  external _SHOW_DOCUMENT: float = "NodeFilter.SHOW_DOCUMENT" [@@bs.val];
  external _SHOW_PROCESSING_INSTRUCTION: float = "NodeFilter.SHOW_PROCESSING_INSTRUCTION" [@@bs.val];
  external _FILTER_REJECT: float = "NodeFilter.FILTER_REJECT" [@@bs.val];
  external _SHOW_CDATA_SECTION: float = "NodeFilter.SHOW_CDATA_SECTION" [@@bs.val];
  external _FILTER_ACCEPT: float = "NodeFilter.FILTER_ACCEPT" [@@bs.val];
  external _SHOW_ALL: float = "NodeFilter.SHOW_ALL" [@@bs.val];
  external _SHOW_DOCUMENT_TYPE: float = "NodeFilter.SHOW_DOCUMENT_TYPE" [@@bs.val];
  external _SHOW_TEXT: float = "NodeFilter.SHOW_TEXT" [@@bs.val];
  external _SHOW_ELEMENT: float = "NodeFilter.SHOW_ELEMENT" [@@bs.val];
  external _SHOW_COMMENT: float = "NodeFilter.SHOW_COMMENT" [@@bs.val];
  external _FILTER_SKIP: float = "NodeFilter.FILTER_SKIP" [@@bs.val];
  external _SHOW_ATTRIBUTE: float = "NodeFilter.SHOW_ATTRIBUTE" [@@bs.val];
  external _SHOW_DOCUMENT_FRAGMENT: float = "NodeFilter.SHOW_DOCUMENT_FRAGMENT" [@@bs.val];
};
let module CloseEvent = {
  type t;
  external code: float = "" [@@bs.get];
  external reason: string = "" [@@bs.get];
  external wasClean: bool = "" [@@bs.get];
};
let module WebSocket = {
  type t;
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
  external constructor: t => string => protocols::(option TODO) => unit = "" [@@bs.send];
  external protocol: string = "" [@@bs.get];
  external readyState: float = "" [@@bs.get];
  external bufferedAmount: float = "" [@@bs.get];
  external onopen: Event => 'a = "" [@@bs.get];
  external extensions: string = "" [@@bs.get];
  external onmessage: MessageEvent => 'a = "" [@@bs.get];
  external onclose: CloseEvent => 'a = "" [@@bs.get];
  external onerror: Event => 'a = "" [@@bs.get];
  external binaryType: string = "" [@@bs.get];
  external url: string = "" [@@bs.get];
  external close: t => code::(option float) => reason::(option string) => unit = "" [@@bs.send];
  external send: t => 'a => unit = "" [@@bs.send];
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
};
let module Worker = {
  type t;
  external constructor: t => string => unit = "" [@@bs.send];
  external onerror: Event => 'a = "" [@@bs.get];
  external onmessage: MessageEvent => 'a = "" [@@bs.get];
  external postMessage: t => 'a => ports::(option 'a) => unit = "" [@@bs.send];
  external terminate: t => unit => unit = "" [@@bs.send];
};
let module SharedWorker = {
  type t;
  external constructor: t => string => unit = "" [@@bs.send];
  external port: MessagePort = "" [@@bs.get];
  external onerror: Event => 'a = "" [@@bs.get];
};
external importScripts: array 'rest => unit = "importScripts" [@@bs.val];
let module WorkerGlobalScope = {
  type t;
  external self: WorkerGlobalScope = "" [@@bs.get];
  external location: WorkerLocation = "" [@@bs.get];
  external navigator: WorkerNavigator = "" [@@bs.get];
  external close: t => unit => unit = "" [@@bs.send];
  external importScripts: t => array 'rest => unit = "" [@@bs.send] [@@bs.splice];
  external onerror: Event => 'a = "" [@@bs.get];
  external onlanguagechange: Event => 'a = "" [@@bs.get];
  external onoffline: Event => 'a = "" [@@bs.get];
  external ononline: Event => 'a = "" [@@bs.get];
  external onrejectionhandled: PromiseRejectionEvent => 'a = "" [@@bs.get];
  external onunhandledrejection: PromiseRejectionEvent => 'a = "" [@@bs.get];
};
let module DedicatedWorkerGlobalScope = {
  type t;
  external onmessage: t => unit => MessageEvent => 'a = "" [@@bs.send];
  external postMessage: t => 'a => transfer::(option Iterable) => unit = "" [@@bs.send];
};
let module SharedWorkerGlobalScope = {
  type t;
  external name: string = "" [@@bs.get];
  external onconnect: MessageEvent => 'a = "" [@@bs.get];
};
let module WorkerLocation = {
  type t;
  external origin: string = "" [@@bs.get];
  external protocol: string = "" [@@bs.get];
  external host: string = "" [@@bs.get];
  external hostname: string = "" [@@bs.get];
  external port: string = "" [@@bs.get];
  external pathname: string = "" [@@bs.get];
  external search: string = "" [@@bs.get];
  external hash: string = "" [@@bs.get];
};
let module WorkerNavigator = {
  type t;
};
let module XDomainRequest = {
  type t;
  external timeout: float = "" [@@bs.get];
  external onerror: Event => 'a = "" [@@bs.get];
  external onload: Event => 'a = "" [@@bs.get];
  external onprogress: Event => 'a = "" [@@bs.get];
  external ontimeout: Event => 'a = "" [@@bs.get];
  external responseText: string = "" [@@bs.get];
  external contentType: string = "" [@@bs.get];
  external open: t => string => string => unit = "" [@@bs.send];
  external abort: t => unit => unit = "" [@@bs.send];
  external send: t => data::(option 'a) => unit = "" [@@bs.send];
  external addEventListener: t => string => 'a => unit => useCapture::(option bool) => unit = "" [@@bs.send];
  external statics: TODO = "" [@@bs.get];
};
let module XMLHttpRequest = {
  type t;
  external responseBody: 'a = "" [@@bs.get];
  external status: float = "" [@@bs.get];
  external readyState: float = "" [@@bs.get];
  external responseText: string = "" [@@bs.get];
  external responseXML: 'a = "" [@@bs.get];
  external ontimeout: ProgressEvent => 'a = "" [@@bs.get];
  external statusText: string = "" [@@bs.get];
  external onreadystatechange: Event => 'a = "" [@@bs.get];
  external timeout: float = "" [@@bs.get];
  external onload: ProgressEvent => 'a = "" [@@bs.get];
  external response: 'a = "" [@@bs.get];
  external withCredentials: bool = "" [@@bs.get];
  external onprogress: ProgressEvent => 'a = "" [@@bs.get];
  external onabort: ProgressEvent => 'a = "" [@@bs.get];
  external responseType: string = "" [@@bs.get];
  external onloadend: ProgressEvent => 'a = "" [@@bs.get];
  external upload: XMLHttpRequestEventTarget = "" [@@bs.get];
  external onerror: ProgressEvent => 'a = "" [@@bs.get];
  external onloadstart: ProgressEvent => 'a = "" [@@bs.get];
  external msCaching: string = "" [@@bs.get];
  external open: t => string => string => async::(option bool) => user::(option string) => password::(option string) => unit = "" [@@bs.send];
  external send: t => data::(option 'a) => unit = "" [@@bs.send];
  external abort: t => unit => unit = "" [@@bs.send];
  external getAllResponseHeaders: t => unit => string = "" [@@bs.send];
  external setRequestHeader: t => string => string => unit = "" [@@bs.send];
  external getResponseHeader: t => string => string = "" [@@bs.send];
  external msCachingEnabled: t => unit => bool = "" [@@bs.send];
  external overrideMimeType: t => string => unit = "" [@@bs.send];
  external _LOADING: float = "" [@@bs.get];
  external _DONE: float = "" [@@bs.get];
  external _UNSENT: float = "" [@@bs.get];
  external _OPENED: float = "" [@@bs.get];
  external _HEADERS_RECEIVED: float = "" [@@bs.get];
  external statics: TODO = "" [@@bs.get];
};
let module XMLHttpRequestEventTarget = {
  type t;
  external onprogress: ProgressEvent => 'a = "" [@@bs.get];
  external onerror: Event => 'a = "" [@@bs.get];
  external onload: Event => 'a = "" [@@bs.get];
  external ontimeout: Event => 'a = "" [@@bs.get];
  external onabort: Event => 'a = "" [@@bs.get];
  external onloadstart: Event => 'a = "" [@@bs.get];
  external onloadend: Event => 'a = "" [@@bs.get];
};
let module XMLSerializer = {
  type t;
  external serializeToString: t => Node => string = "" [@@bs.send];
};
let module Geolocation = {
  type t;
  external getCurrentPosition: Position => 'a => error::(option PositionError => 'a) => options::(option PositionOptions) => 'a = "" [@@bs.get];
  external watchPosition: Position => 'a => error::(option PositionError => 'a) => options::(option PositionOptions) => 'a = "" [@@bs.get];
  external clearWatch: 'a = "" [@@bs.get];
};
let module Position = {
  type t;
  external coords: Coordinates = "" [@@bs.get];
  external timestamp: float = "" [@@bs.get];
};
let module Coordinates = {
  type t;
  external latitude: float = "" [@@bs.get];
  external longitude: float = "" [@@bs.get];
  external altitude: float = "" [@@bs.get];
  external accuracy: float = "" [@@bs.get];
  external altitudeAccuracy: float = "" [@@bs.get];
  external heading: float = "" [@@bs.get];
};
let module PositionError = {
  type t;
  external code: float = "" [@@bs.get];
  external message: string = "" [@@bs.get];
  external _PERMISSION_DENIED: float = "" [@@bs.get];
  external _POSITION_UNAVAILABLE: float = "" [@@bs.get];
  external _TIMEOUT: float = "" [@@bs.get];
};
type TODO;
let module AudioContext = {
  type t;
  external currentTime: float = "" [@@bs.get];
  external destination: AudioDestinationNode = "" [@@bs.get];
  external listener: AudioListener = "" [@@bs.get];
  external sampleRate: float = "" [@@bs.get];
  external state: 'a = "" [@@bs.get];
  external onstatechange: 'a => 'a = "" [@@bs.get];
  external close: t => unit => unit = "" [@@bs.send];
  external createBuffer: t => float => float => float => AudioBuffer = "" [@@bs.send];
  external createBufferSource: t => myMediaElement::(option HTMLMediaElement) => AudioBufferSourceNode = "" [@@bs.send];
  external createMediaElementSource: t => HTMLMediaElement => MediaElementAudioSourceNode = "" [@@bs.send];
  external createMediaStreamSource: t => unit => MediaStreamAudioSourceNode = "" [@@bs.send];
  external createMediaStreamDestination: t => unit => MediaStream = "" [@@bs.send];
  external createScriptProcessor: t => float => float => float => ScriptProcessorNode = "" [@@bs.send];
  external createAnalyser: t => unit => AnalyserNode = "" [@@bs.send];
  external createBiquadFilter: t => unit => BiquadFilterNode = "" [@@bs.send];
  external createChannelMerger: t => numberOfInputs::(option float) => ChannelMergerNode = "" [@@bs.send];
  external createChannelSplitter: t => numberOfInputs::(option float) => ChannelSplitterNode = "" [@@bs.send];
  external createConvolver: t => unit => ConvolverNode = "" [@@bs.send];
  external createDelay: t => maxDelayTime::(option float) => DelayNode = "" [@@bs.send];
  external createDynamicCompressor: t => unit => DynamicsCompressorNode = "" [@@bs.send];
  external createGain: t => unit => GainNode = "" [@@bs.send];
  external createOscillator: t => unit => OscillatorNode = "" [@@bs.send];
  external createPanner: t => unit => PannerNode = "" [@@bs.send];
  external createPeriodicWave: t => Float32Array => Float32Array => options::(option TODO) => PeriodicWave = "" [@@bs.send];
  external createWaveShaper: t => unit => WaveShaperNode = "" [@@bs.send];
  external decodeAudioData: t => ArrayBuffer => (unit => unit) => (unit => unit) => unit = "" [@@bs.send];
  external decodeAudioData: t => ArrayBuffer => Promise = "" [@@bs.send];
  external resume: t => unit => Promise = "" [@@bs.send];
  external suspend: t => unit => Promise = "" [@@bs.send];
};
let module AudioNode = {
  type t;
  external context: AudioContext = "" [@@bs.get];
  external numberOfInputs: float = "" [@@bs.get];
  external numberOfOutputs: float = "" [@@bs.get];
  external channelCount: float = "" [@@bs.get];
  external channelCoundMode: 'a = "" [@@bs.get];
  external channelInterpretation: TODO = "" [@@bs.get];
  external connect: t => AudioNode => output::(option float) => input::(option float) => AudioNode = "" [@@bs.send];
  external connect: t => AudioParam => output::(option float) => unit = "" [@@bs.send];
  external disconnect: t => destination::(option AudioNode) => output::(option float) => input::(option float) => unit = "" [@@bs.send];
};
let module AudioParam = {
  type t;
  external value: float = "" [@@bs.get];
  external defaultValue: float = "" [@@bs.get];
  external setValueAtTime: t => float => float => this = "" [@@bs.send];
  external linearRampToValueAtTime: t => float => float => this = "" [@@bs.send];
  external exponentialRampToValueAtTime: t => float => float => this = "" [@@bs.send];
  external setTargetAtTime: t => float => float => float => this = "" [@@bs.send];
  external setValueCurveAtTime: t => Float32Array => float => float => this = "" [@@bs.send];
  external cancelScheduledValues: t => float => this = "" [@@bs.send];
};
let module AudioDestinationNode = {
  type t;
  external maxChannelCount: float = "" [@@bs.get];
};
let module AudioListener = {
  type t;
  external setOrientation: t => float => float => float => float => float => float => unit = "" [@@bs.send];
};
let module AudioBuffer = {
  type t;
  external sampleRate: float = "" [@@bs.get];
  external length: float = "" [@@bs.get];
  external duration: float = "" [@@bs.get];
  external numberOfChannels: float = "" [@@bs.get];
  external getChannelData: t => float => Float32Array = "" [@@bs.send];
  external copyFromChannel: t => Float32Array => float => startInChannel::(option float) => unit = "" [@@bs.send];
  external copyToChannel: t => Float32Array => float => startInChannel::(option float) => unit = "" [@@bs.send];
};
let module AudioBufferSourceNode = {
  type t;
  external buffer: AudioBuffer = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external loop: bool = "" [@@bs.get];
  external loopStart: float = "" [@@bs.get];
  external loopEnd: float = "" [@@bs.get];
  external playbackRate: AudioParam = "" [@@bs.get];
  external onended: 'a => 'a = "" [@@bs.get];
  external start: t => when::(option float) => offset::(option float) => duration::(option float) => unit = "" [@@bs.send];
  external stop: t => when::(option float) => unit = "" [@@bs.send];
};
let module MediaStream = {
  type t;
  external active: bool = "" [@@bs.get];
  external ended: bool = "" [@@bs.get];
  external id: string = "" [@@bs.get];
  external onactive: 'a => 'a = "" [@@bs.get];
  external onaddtrack: 'a => 'a = "" [@@bs.get];
  external onended: 'a => 'a = "" [@@bs.get];
  external oninactive: 'a => 'a = "" [@@bs.get];
  external onremovetrack: 'a => 'a = "" [@@bs.get];
  external addTrack: t => MediaStreamTrack => unit = "" [@@bs.send];
  external clone: t => unit => MediaStream = "" [@@bs.send];
  external getAudioTracks: t => unit => TODO = "" [@@bs.send];
  external getTrackById: t => trackid::(option string) => TODO = "" [@@bs.send];
  external getTracks: t => unit => TODO = "" [@@bs.send];
  external getVideoTracks: t => unit => TODO = "" [@@bs.send];
  external removeTrack: t => MediaStreamTrack => unit = "" [@@bs.send];
};
let module MediaStreamTrack = {
  type t;
  external enabled: bool = "" [@@bs.get];
  external id: string = "" [@@bs.get];
  external kind: string = "" [@@bs.get];
  external label: string = "" [@@bs.get];
  external muted: bool = "" [@@bs.get];
  external readonly: bool = "" [@@bs.get];
  external readyState: TODO = "" [@@bs.get];
  external remote: bool = "" [@@bs.get];
  external onstarted: 'a => 'a = "" [@@bs.get];
  external onmute: 'a => 'a = "" [@@bs.get];
  external onunmute: 'a => 'a = "" [@@bs.get];
  external onoverconstrained: 'a => 'a = "" [@@bs.get];
  external onended: 'a => 'a = "" [@@bs.get];
  external getConstraints: t => unit => 'a = "" [@@bs.send];
  external applyConstraints: t => unit => 'a = "" [@@bs.send];
  external getSettings: t => unit => 'a = "" [@@bs.send];
  external getCapabilities: t => unit => 'a = "" [@@bs.send];
  external clone: t => unit => MediaStreamTrack = "" [@@bs.send];
  external stop: t => unit => unit = "" [@@bs.send];
};
let module MediaElementAudioSourceNode = {
  type t;
};
let module MediaStreamAudioSourceNode = {
  type t;
};
let module ScriptProcessorNode = {
  type t;
  external bufferSize: float = "" [@@bs.get];
  external onaudioprocess: 'a => 'a = "" [@@bs.get];
};
let module AnalyserNode = {
  type t;
  external fftSize: float = "" [@@bs.get];
  external frequencyBinCount: float = "" [@@bs.get];
  external minDecibels: float = "" [@@bs.get];
  external maxDecibels: float = "" [@@bs.get];
  external smoothingTimeConstant: float = "" [@@bs.get];
  external getFloatFrequencyData: t => Float32Array => Float32Array = "" [@@bs.send];
  external getByteFrequencyData: t => Uint8Array => Uint8Array = "" [@@bs.send];
  external getFloatTimeDomainData: t => Float32Array => Float32Array = "" [@@bs.send];
  external getByteTimeDomainData: t => Uint8Array => Uint8Array = "" [@@bs.send];
};
let module BiquadFilterNode = {
  type t;
  external frequency: AudioParam = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external _Q: AudioParam = "" [@@bs.get];
  external gain: AudioParam = "" [@@bs.get];
  external _type: TODO = "" [@@bs.get];
  external getFrequencyResponse: t => Float32Array => Float32Array => Float32Array => BiquadFilterNode = "" [@@bs.send];
};
let module ChannelMergerNode = {
  type t;
};
let module ChannelSplitterNode = {
  type t;
};
let module ConvolverNode = {
  type t;
  external buffer: AudioBuffer = "" [@@bs.get];
  external normalize: bool = "" [@@bs.get];
};
let module DelayNode = {
  type t;
  external delayTime: float = "" [@@bs.get];
};
let module DynamicsCompressorNode = {
  type t;
  external threshold: AudioParam = "" [@@bs.get];
  external knee: AudioParam = "" [@@bs.get];
  external ratio: AudioParam = "" [@@bs.get];
  external reduction: AudioParam = "" [@@bs.get];
  external attack: AudioParam = "" [@@bs.get];
  external release: AudioParam = "" [@@bs.get];
};
let module GainNode = {
  type t;
  external gain: AudioParam = "" [@@bs.get];
};
let module OscillatorNode = {
  type t;
  external frequency: AudioParam = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external _type: TODO = "" [@@bs.get];
  external start: t => when::(option float) => unit = "" [@@bs.send];
  external stop: t => when::(option float) => unit = "" [@@bs.send];
  external setPeriodicWave: t => PeriodicWave => unit = "" [@@bs.send];
};
let module PannerNode = {
  type t;
  external panningModel: TODO = "" [@@bs.get];
  external distanceModel: TODO = "" [@@bs.get];
  external refDistance: float = "" [@@bs.get];
  external maxDistance: float = "" [@@bs.get];
  external rollofFactor: float = "" [@@bs.get];
  external coneInnerAngle: float = "" [@@bs.get];
  external coneOuterAngle: float = "" [@@bs.get];
  external coneOuterGain: float = "" [@@bs.get];
  external setPosition: t => float => float => float => unit = "" [@@bs.send];
  external setOrientation: t => float => float => float => unit = "" [@@bs.send];
};
let module PeriodicWave = {
  type t;
};
let module WaveShaperNode = {
  type t;
  external curve: Float32Array = "" [@@bs.get];
  external oversample: TODO = "" [@@bs.get];
};
let module AudioContextInstance = {
  external currentTime: float = "AudioContext.currentTime" [@@bs.val];
  external destination: AudioDestinationNode = "AudioContext.destination" [@@bs.val];
  external listener: AudioListener = "AudioContext.listener" [@@bs.val];
  external sampleRate: float = "AudioContext.sampleRate" [@@bs.val];
  external state: 'a = "AudioContext.state" [@@bs.val];
  external onstatechange: 'a => 'a = "AudioContext.onstatechange" [@@bs.val];
  external close: unit => unit = "AudioContext.close" [@@bs.val];
  external createBuffer: float => float => float => AudioBuffer = "AudioContext.createBuffer" [@@bs.val];
  external createBufferSource: myMediaElement::(option HTMLMediaElement) => AudioBufferSourceNode = "AudioContext.createBufferSource" [@@bs.val];
  external createMediaElementSource: HTMLMediaElement => MediaElementAudioSourceNode = "AudioContext.createMediaElementSource" [@@bs.val];
  external createMediaStreamSource: unit => MediaStreamAudioSourceNode = "AudioContext.createMediaStreamSource" [@@bs.val];
  external createMediaStreamDestination: unit => MediaStream = "AudioContext.createMediaStreamDestination" [@@bs.val];
  external createScriptProcessor: float => float => float => ScriptProcessorNode = "AudioContext.createScriptProcessor" [@@bs.val];
  external createAnalyser: unit => AnalyserNode = "AudioContext.createAnalyser" [@@bs.val];
  external createBiquadFilter: unit => BiquadFilterNode = "AudioContext.createBiquadFilter" [@@bs.val];
  external createChannelMerger: numberOfInputs::(option float) => ChannelMergerNode = "AudioContext.createChannelMerger" [@@bs.val];
  external createChannelSplitter: numberOfInputs::(option float) => ChannelSplitterNode = "AudioContext.createChannelSplitter" [@@bs.val];
  external createConvolver: unit => ConvolverNode = "AudioContext.createConvolver" [@@bs.val];
  external createDelay: maxDelayTime::(option float) => DelayNode = "AudioContext.createDelay" [@@bs.val];
  external createDynamicCompressor: unit => DynamicsCompressorNode = "AudioContext.createDynamicCompressor" [@@bs.val];
  external createGain: unit => GainNode = "AudioContext.createGain" [@@bs.val];
  external createOscillator: unit => OscillatorNode = "AudioContext.createOscillator" [@@bs.val];
  external createPanner: unit => PannerNode = "AudioContext.createPanner" [@@bs.val];
  external createPeriodicWave: Float32Array => Float32Array => options::(option TODO) => PeriodicWave = "AudioContext.createPeriodicWave" [@@bs.val];
  external createWaveShaper: unit => WaveShaperNode = "AudioContext.createWaveShaper" [@@bs.val];
  external decodeAudioData: ArrayBuffer => (unit => unit) => (unit => unit) => unit = "AudioContext.decodeAudioData" [@@bs.val];
  external decodeAudioData: ArrayBuffer => Promise = "AudioContext.decodeAudioData" [@@bs.val];
  external resume: unit => Promise = "AudioContext.resume" [@@bs.val];
  external suspend: unit => Promise = "AudioContext.suspend" [@@bs.val];
};
type TODO;
let module Headers = {
  type t;
  external _@@iterator: t => unit => Iterator = "" [@@bs.send];
  external constructor: t => init::(option HeadersInit) => unit = "" [@@bs.send];
  external append: t => string => string => unit = "" [@@bs.send];
  external delete: t => string => unit = "" [@@bs.send];
  external entries: t => unit => Iterator = "" [@@bs.send];
  external get: t => string => string = "" [@@bs.send];
  external getAll: t => string => Array = "" [@@bs.send];
  external has: t => string => bool = "" [@@bs.send];
  external keys: t => unit => Iterator = "" [@@bs.send];
  external set: t => string => string => unit = "" [@@bs.send];
  external values: t => unit => Iterator = "" [@@bs.send];
};
let module URLSearchParams = {
  type t;
  external _@@iterator: t => unit => Iterator = "" [@@bs.send];
  external constructor: t => query::(option TODO) => unit = "" [@@bs.send];
  external append: t => string => string => unit = "" [@@bs.send];
  external delete: t => string => unit = "" [@@bs.send];
  external entries: t => unit => Iterator = "" [@@bs.send];
  external get: t => string => string = "" [@@bs.send];
  external getAll: t => string => Array = "" [@@bs.send];
  external has: t => string => bool = "" [@@bs.send];
  external keys: t => unit => Iterator = "" [@@bs.send];
  external set: t => string => string => unit = "" [@@bs.send];
  external values: t => unit => Iterator = "" [@@bs.send];
};
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
let module Response = {
  type t;
  external constructor: t => input::(option TODO) => init::(option ResponseOptions) => unit = "" [@@bs.send];
  external clone: t => unit => Response = "" [@@bs.send];
  external error: unit => Response = "" [@@bs.val];
  external redirect: string => float => Response = "" [@@bs.val];
  external _type: ResponseType = "" [@@bs.get];
  external url: string = "" [@@bs.get];
  external useFinalURL: bool = "" [@@bs.get];
  external ok: bool = "" [@@bs.get];
  external status: float = "" [@@bs.get];
  external statusText: string = "" [@@bs.get];
  external headers: Headers = "" [@@bs.get];
  external bodyUsed: bool = "" [@@bs.get];
  external arrayBuffer: t => unit => Promise = "" [@@bs.send];
  external blob: t => unit => Promise = "" [@@bs.send];
  external formData: t => unit => Promise = "" [@@bs.send];
  external json: t => unit => Promise = "" [@@bs.send];
  external text: t => unit => Promise = "" [@@bs.send];
};
let module Request = {
  type t;
  external constructor: t => TODO => init::(option RequestOptions) => unit = "" [@@bs.send];
  external clone: t => unit => Request = "" [@@bs.send];
  external url: string = "" [@@bs.get];
  external cache: CacheType = "" [@@bs.get];
  external credentials: CredentialsType = "" [@@bs.get];
  external headers: Headers = "" [@@bs.get];
  external integrity: string = "" [@@bs.get];
  external method: MethodType = "" [@@bs.get];
  external mode: ModeType = "" [@@bs.get];
  external redirect: RedirectType = "" [@@bs.get];
  external referrer: string = "" [@@bs.get];
  external referrerPolicy: ReferrerPolicyType = "" [@@bs.get];
  external bodyUsed: bool = "" [@@bs.get];
  external arrayBuffer: t => unit => Promise = "" [@@bs.send];
  external blob: t => unit => Promise = "" [@@bs.send];
  external formData: t => unit => Promise = "" [@@bs.send];
  external json: t => unit => Promise = "" [@@bs.send];
  external text: t => unit => Promise = "" [@@bs.send];
};
external fetch: TODO => init::(option RequestOptions) => Promise = "fetch" [@@bs.val];
let module MessagePort = {
  type t;
  external postMessage: t => 'a => transfer::(option Iterable) => unit = "" [@@bs.send];
  external start: t => unit => unit = "" [@@bs.send];
  external close: t => unit => unit = "" [@@bs.send];
  external onmessage: Event => 'a = "" [@@bs.get];
};
let module MessageChannel = {
  type t;
  external port1: MessagePort = "" [@@bs.get];
  external port2: MessagePort = "" [@@bs.get];
};
