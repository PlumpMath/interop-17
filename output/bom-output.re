let module Screen = {
  type t;
  external create: unit => t = "Screen" [@@bs.new]; 
  external availHeight: float = "" [@@bs.get];
  external availLeft: float = "" [@@bs.get];
  external availTop: float = "" [@@bs.get];
  external availWidth: float = "" [@@bs.get];
  external colorDepth: float = "" [@@bs.get];
  external height: float = "" [@@bs.get];
  external left: float = "" [@@bs.get];
  external mozOrientation: string = "" [@@bs.get];
  external onmozorientationchange: 'a = "" [@@bs.get];
  external orientation: TODO = "" [@@bs.get];
  external pixelDepth: float = "" [@@bs.get];
  external top: float = "" [@@bs.get];
  external width: float = "" [@@bs.get];
  external mozLockOrientation: (unit => unit) = "" [@@bs.get];
  external mozUnlockOrientation: (unit => unit) = "" [@@bs.get];
  external mozOrientation: string = "" [@@bs.get];
  external onmozorientationchange: (unit => unit) = "" [@@bs.get];
};
let module ScreenInstance = {
  external availHeight: float = "screen.availHeight" [@@bs.val];
  external availLeft: float = "screen.availLeft" [@@bs.val];
  external availTop: float = "screen.availTop" [@@bs.val];
  external availWidth: float = "screen.availWidth" [@@bs.val];
  external colorDepth: float = "screen.colorDepth" [@@bs.val];
  external height: float = "screen.height" [@@bs.val];
  external left: float = "screen.left" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: 'a = "screen.onmozorientationchange" [@@bs.val];
  external orientation: TODO = "screen.orientation" [@@bs.val];
  external pixelDepth: float = "screen.pixelDepth" [@@bs.val];
  external top: float = "screen.top" [@@bs.val];
  external width: float = "screen.width" [@@bs.val];
  external mozLockOrientation: (unit => unit) = "screen.mozLockOrientation" [@@bs.val];
  external mozUnlockOrientation: (unit => unit) = "screen.mozUnlockOrientation" [@@bs.val];
  external mozOrientation: string = "screen.mozOrientation" [@@bs.val];
  external onmozorientationchange: (unit => unit) = "screen.onmozorientationchange" [@@bs.val];
};
external window: 'a = "window" [@@bs.val];
type TODO;
type TODO;
let module NavigatorCommon = {
  type t;
  external create: unit => t = "NavigatorCommon" [@@bs.new]; 
  let appName = "Netscape";
  external appVersion: string = "" [@@bs.get];
  external platform: string = "" [@@bs.get];
  external userAgent: string = "" [@@bs.get];
  external language: string = "" [@@bs.get];
  external languages: Array = "" [@@bs.get];
  external onLine: bool = "" [@@bs.get];
  external hardwareConcurrency: float = "" [@@bs.get];
};
let module Navigator = {
  type t;
  external create: unit => t = "Navigator" [@@bs.new]; 
  let appCodeName = "Mozilla";
  external buildID: string = "" [@@bs.get];
  external cookieEnabled: bool = "" [@@bs.get];
  external doNotTrack: 'a = "" [@@bs.get];
  external geolocation: Geolocation = "" [@@bs.get];
  external mediaDevices: Object = "" [@@bs.get];
  external javaEnabled: (unit => unit) = "" [@@bs.get];
  external maxTouchPoints: float = "" [@@bs.get];
  external mimeTypes: MimeTypeArray = "" [@@bs.get];
  external oscpu: string = "" [@@bs.get];
  external permissions: 'a = "" [@@bs.get];
  external plugins: PluginArray = "" [@@bs.get];
  let product = "Gecko";
  external productSub: TODO = "" [@@bs.get];
  external serviceWorker: Object = "" [@@bs.get];
  external vendor: TODO = "" [@@bs.get];
  let vendorSub = "";
  external getBattery: (unit => Promise) = "" [@@bs.get];
  external getGamepads: (unit => TODO) = "" [@@bs.get];
  external webkitGetGamepads: (unit => unit) = "" [@@bs.get];
  external mozGetGamepads: (unit => unit) = "" [@@bs.get];
  external mozGamepads: 'a = "" [@@bs.get];
  external gamepads: 'a = "" [@@bs.get];
  external webkitGamepads: 'a = "" [@@bs.get];
  external requestMIDIAccess: (unit => unit) = "" [@@bs.get];
  external registerContentHandler: t => (string => string => string => unit) = "" [@@bs.send];
  external registerProtocolHandler: t => (string => string => string => unit) = "" [@@bs.send];
  external requestMediaKeySystemAccess: (string => TODO => Promise) = "" [@@bs.get];
  external sendBeacon: (unit => unit) = "" [@@bs.get];
  external getUserMedia: (unit => unit) = "" [@@bs.get];
  external webkitGetUserMedia: (unit => unit) = "" [@@bs.get];
  external mozGetUserMedia: (unit => unit) = "" [@@bs.get];
  external msGetUserMedia: (unit => unit) = "" [@@bs.get];
  external taintEnabled: (unit => unit) = "" [@@bs.get];
  external vibrate: (TODO => bool) = "" [@@bs.get];
};
let module NavigatorInstance = {
  let appCodeName = "Mozilla";
  external buildID: string = "navigator.buildID" [@@bs.val];
  external cookieEnabled: bool = "navigator.cookieEnabled" [@@bs.val];
  external doNotTrack: 'a = "navigator.doNotTrack" [@@bs.val];
  external geolocation: Geolocation = "navigator.geolocation" [@@bs.val];
  external mediaDevices: Object = "navigator.mediaDevices" [@@bs.val];
  external javaEnabled: (unit => unit) = "navigator.javaEnabled" [@@bs.val];
  external maxTouchPoints: float = "navigator.maxTouchPoints" [@@bs.val];
  external mimeTypes: MimeTypeArray = "navigator.mimeTypes" [@@bs.val];
  external oscpu: string = "navigator.oscpu" [@@bs.val];
  external permissions: 'a = "navigator.permissions" [@@bs.val];
  external plugins: PluginArray = "navigator.plugins" [@@bs.val];
  let product = "Gecko";
  external productSub: TODO = "navigator.productSub" [@@bs.val];
  external serviceWorker: Object = "navigator.serviceWorker" [@@bs.val];
  external vendor: TODO = "navigator.vendor" [@@bs.val];
  let vendorSub = "";
  external getBattery: (unit => Promise) = "navigator.getBattery" [@@bs.val];
  external getGamepads: (unit => TODO) = "navigator.getGamepads" [@@bs.val];
  external webkitGetGamepads: (unit => unit) = "navigator.webkitGetGamepads" [@@bs.val];
  external mozGetGamepads: (unit => unit) = "navigator.mozGetGamepads" [@@bs.val];
  external mozGamepads: 'a = "navigator.mozGamepads" [@@bs.val];
  external gamepads: 'a = "navigator.gamepads" [@@bs.val];
  external webkitGamepads: 'a = "navigator.webkitGamepads" [@@bs.val];
  external requestMIDIAccess: (unit => unit) = "navigator.requestMIDIAccess" [@@bs.val];
  external registerContentHandler: (string => string => string => unit) = "navigator.registerContentHandler" [@@bs.send];
  external registerProtocolHandler: (string => string => string => unit) = "navigator.registerProtocolHandler" [@@bs.send];
  external requestMediaKeySystemAccess: (string => TODO => Promise) = "navigator.requestMediaKeySystemAccess" [@@bs.val];
  external sendBeacon: (unit => unit) = "navigator.sendBeacon" [@@bs.val];
  external getUserMedia: (unit => unit) = "navigator.getUserMedia" [@@bs.val];
  external webkitGetUserMedia: (unit => unit) = "navigator.webkitGetUserMedia" [@@bs.val];
  external mozGetUserMedia: (unit => unit) = "navigator.mozGetUserMedia" [@@bs.val];
  external msGetUserMedia: (unit => unit) = "navigator.msGetUserMedia" [@@bs.val];
  external taintEnabled: (unit => unit) = "navigator.taintEnabled" [@@bs.val];
  external vibrate: (TODO => bool) = "navigator.vibrate" [@@bs.val];
};
let module MimeType = {
  type t;
  external create: unit => t = "MimeType" [@@bs.new]; 
  external _type: string = "" [@@bs.get];
  external description: string = "" [@@bs.get];
  external suffixes: string = "" [@@bs.get];
  external enabledPlugin: Plugin = "" [@@bs.get];
};
let module MimeTypeArray = {
  type t;
  external create: unit => t = "MimeTypeArray" [@@bs.new]; 
  external length: float = "" [@@bs.get];
  external item: t => (float => MimeType) = "" [@@bs.send];
  external namedItem: t => (string => MimeType) = "" [@@bs.send];
};
let module Plugin = {
  type t;
  external create: unit => t = "Plugin" [@@bs.new]; 
  external description: string = "" [@@bs.get];
  external filename: string = "" [@@bs.get];
  external name: string = "" [@@bs.get];
  external version: string = "" [@@bs.get];
  external length: float = "" [@@bs.get];
  external item: t => (float => MimeType) = "" [@@bs.send];
  external namedItem: t => (string => MimeType) = "" [@@bs.send];
};
let module PluginArray = {
  type t;
  external create: unit => t = "PluginArray" [@@bs.new]; 
  external length: float = "" [@@bs.get];
  external item: t => (float => Plugin) = "" [@@bs.send];
  external namedItem: t => (string => Plugin) = "" [@@bs.send];
  external refresh: t => (unit => unit) = "" [@@bs.send];
};
let module PerformanceTiming = {
  type t;
  external create: unit => t = "PerformanceTiming" [@@bs.new]; 
  external connectEnd: float = "" [@@bs.get];
  external connectStart: float = "" [@@bs.get];
  external domainLookupEnd: float = "" [@@bs.get];
  external domainLookupStart: float = "" [@@bs.get];
  external domComplete: float = "" [@@bs.get];
  external domContentLoadedEventEnd: float = "" [@@bs.get];
  external domContentLoadedEventStart: float = "" [@@bs.get];
  external domInteractive: float = "" [@@bs.get];
  external domLoading: float = "" [@@bs.get];
  external fetchStart: float = "" [@@bs.get];
  external loadEventEnd: float = "" [@@bs.get];
  external loadEventStart: float = "" [@@bs.get];
  external navigationStart: float = "" [@@bs.get];
  external redirectEnd: float = "" [@@bs.get];
  external redirectStart: float = "" [@@bs.get];
  external requestStart: float = "" [@@bs.get];
  external responseEnd: float = "" [@@bs.get];
  external responseStart: float = "" [@@bs.get];
  external secureConnectionStart: float = "" [@@bs.get];
  external unloadEventEnd: float = "" [@@bs.get];
  external unloadEventStart: float = "" [@@bs.get];
};
let module PerformanceNavigation = {
  type t;
  external create: unit => t = "PerformanceNavigation" [@@bs.new]; 
  let _TYPE_NAVIGATE = 0.;
  let _TYPE_RELOAD = 1.;
  let _TYPE_BACK_FORWARD = 2.;
  let _TYPE_RESERVED = 255.;
  external _type: TODO = "" [@@bs.get];
  external redirectCount: float = "" [@@bs.get];
};
type TODO;
let module PerformanceEntry = {
  type t;
  external create: unit => t = "PerformanceEntry" [@@bs.new]; 
  external name: string = "" [@@bs.get];
  external entryType: string = "" [@@bs.get];
  external startTime: float = "" [@@bs.get];
  external duration: float = "" [@@bs.get];
  external toJSON: t => (unit => string) = "" [@@bs.send];
};
let module Performance = {
  type t;
  external create: unit => t = "Performance" [@@bs.new]; 
  external navigation: PerformanceNavigation = "" [@@bs.get];
  external onresourcetimingbufferfull: (Event => 'a) = "" [@@bs.get];
  external timing: PerformanceTiming = "" [@@bs.get];
  external clearMarks: t => (name::(option string) => unit) = "" [@@bs.send];
  external clearMeasures: t => (name::(option string) => unit) = "" [@@bs.send];
  external clearResourceTimings: t => (unit => unit) = "" [@@bs.send];
  external getEntries: t => (options::(option PerformanceEntryFilterOptions) => Array) = "" [@@bs.send];
  external getEntriesByName: t => (string => type::(option string) => Array) = "" [@@bs.send];
  external getEntriesByType: t => (string => Array) = "" [@@bs.send];
  external mark: t => (string => unit) = "" [@@bs.send];
  external measure: t => (string => startMark::(option string) => endMark::(option string) => unit) = "" [@@bs.send];
  external now: t => (unit => float) = "" [@@bs.send];
  external setResourceTimingBufferSize: t => (float => unit) = "" [@@bs.send];
  external toJSON: t => (unit => string) = "" [@@bs.send];
};
let module PerformanceInstance = {
  external navigation: PerformanceNavigation = "performance.navigation" [@@bs.val];
  external onresourcetimingbufferfull: (Event => 'a) = "performance.onresourcetimingbufferfull" [@@bs.val];
  external timing: PerformanceTiming = "performance.timing" [@@bs.val];
  external clearMarks: (name::(option string) => unit) = "performance.clearMarks" [@@bs.send];
  external clearMeasures: (name::(option string) => unit) = "performance.clearMeasures" [@@bs.send];
  external clearResourceTimings: (unit => unit) = "performance.clearResourceTimings" [@@bs.send];
  external getEntries: (options::(option PerformanceEntryFilterOptions) => Array) = "performance.getEntries" [@@bs.send];
  external getEntriesByName: (string => type::(option string) => Array) = "performance.getEntriesByName" [@@bs.send];
  external getEntriesByType: (string => Array) = "performance.getEntriesByType" [@@bs.send];
  external mark: (string => unit) = "performance.mark" [@@bs.send];
  external measure: (string => startMark::(option string) => endMark::(option string) => unit) = "performance.measure" [@@bs.send];
  external now: (unit => float) = "performance.now" [@@bs.send];
  external setResourceTimingBufferSize: (float => unit) = "performance.setResourceTimingBufferSize" [@@bs.send];
  external toJSON: (unit => string) = "performance.toJSON" [@@bs.send];
};
let module History = {
  type t;
  external create: unit => t = "History" [@@bs.new]; 
  external length: float = "" [@@bs.get];
  external scrollRestoration: TODO = "" [@@bs.get];
  external state: 'a = "" [@@bs.get];
  external back: t => (unit => unit) = "" [@@bs.send];
  external forward: t => (unit => unit) = "" [@@bs.send];
  external go: t => (delta::(option 'a) => unit) = "" [@@bs.send];
  external pushState: t => ('a => string => url::(option string) => unit) = "" [@@bs.send];
  external replaceState: t => ('a => string => url::(option string) => unit) = "" [@@bs.send];
};
let module HistoryInstance = {
  external length: float = "history.length" [@@bs.val];
  external scrollRestoration: TODO = "history.scrollRestoration" [@@bs.val];
  external state: 'a = "history.state" [@@bs.val];
  external back: (unit => unit) = "history.back" [@@bs.send];
  external forward: (unit => unit) = "history.forward" [@@bs.send];
  external go: (delta::(option 'a) => unit) = "history.go" [@@bs.send];
  external pushState: ('a => string => url::(option string) => unit) = "history.pushState" [@@bs.send];
  external replaceState: ('a => string => url::(option string) => unit) = "history.replaceState" [@@bs.send];
};
let module Location = {
  type t;
  external create: unit => t = "Location" [@@bs.new]; 
  external ancestorOrigins: TODO = "" [@@bs.get];
  external hash: string = "" [@@bs.get];
  external host: string = "" [@@bs.get];
  external hostname: string = "" [@@bs.get];
  external href: string = "" [@@bs.get];
  external origin: string = "" [@@bs.get];
  external pathname: string = "" [@@bs.get];
  external port: string = "" [@@bs.get];
  external protocol: string = "" [@@bs.get];
  external search: string = "" [@@bs.get];
  external assign: t => (string => unit) = "" [@@bs.send];
  external reload: t => (flag::(option bool) => unit) = "" [@@bs.send];
  external replace: t => (string => unit) = "" [@@bs.send];
  external toString: t => (unit => string) = "" [@@bs.send];
};
let module LocationInstance = {
  external ancestorOrigins: TODO = "location.ancestorOrigins" [@@bs.val];
  external hash: string = "location.hash" [@@bs.val];
  external host: string = "location.host" [@@bs.val];
  external hostname: string = "location.hostname" [@@bs.val];
  external href: string = "location.href" [@@bs.val];
  external origin: string = "location.origin" [@@bs.val];
  external pathname: string = "location.pathname" [@@bs.val];
  external port: string = "location.port" [@@bs.val];
  external protocol: string = "location.protocol" [@@bs.val];
  external search: string = "location.search" [@@bs.val];
  external assign: (string => unit) = "location.assign" [@@bs.send];
  external reload: (flag::(option bool) => unit) = "location.reload" [@@bs.send];
  external replace: (string => unit) = "location.replace" [@@bs.send];
  external toString: (unit => string) = "location.toString" [@@bs.send];
};
let module DOMParser = {
  type t;
  external create: unit => t = "DOMParser" [@@bs.new]; 
  external parseFromString: t => (string => string => Document) = "" [@@bs.send];
};
let module FormData = {
  type t;
  external create: unit => t = "FormData" [@@bs.new]; 
  external append: t => ('a => 'a => blobName::(option string) => unit) = "" [@@bs.send];
};
let module MutationRecord = {
  type t;
  external create: unit => t = "MutationRecord" [@@bs.new]; 
  external _type: TODO = "" [@@bs.get];
  external target: Node = "" [@@bs.get];
  external addedNodes: NodeList = "" [@@bs.get];
  external removedNodes: NodeList = "" [@@bs.get];
  external previousSibling: TODO = "" [@@bs.get];
  external nextSibling: TODO = "" [@@bs.get];
  external attributeName: TODO = "" [@@bs.get];
  external attributeNamespace: TODO = "" [@@bs.get];
  external oldValue: TODO = "" [@@bs.get];
};
let module MutationObserver = {
  type t;
  external create: unit => t = "MutationObserver" [@@bs.new]; 
  external constructor: t => ((Array => MutationObserver => 'a) => unit) = "" [@@bs.send];
  external observe: t => (Node => TODO => unit) = "" [@@bs.send];
  external takeRecords: t => (unit => Array) = "" [@@bs.send];
  external disconnect: t => (unit => unit) = "" [@@bs.send];
};
let module NodeFilter = {
  external acceptNode: (Node => float) = "NodeFilter.acceptNode" [@@bs.send];
  external _SHOW_ENTITY_REFERENCE: float = "NodeFilter.SHOW_ENTITY_REFERENCE" [@@bs.val];
  external _SHOW_NOTATION: float = "NodeFilter.SHOW_NOTATION" [@@bs.val];
  external _SHOW_ENTITY: float = "NodeFilter.SHOW_ENTITY" [@@bs.val];
  external _SHOW_DOCUMENT: float = "NodeFilter.SHOW_DOCUMENT" [@@bs.val];
  external _SHOW_PROCESSING_INSTRUCTION: float = "NodeFilter.SHOW_PROCESSING_INSTRUCTION" [@@bs.val];
  external _FILTER_REJECT: float = "NodeFilter.FILTER_REJECT" [@@bs.val];
  external _SHOW_CDATA_SECTION: float = "NodeFilter.SHOW_CDATA_SECTION" [@@bs.val];
  external _FILTER_ACCEPT: float = "NodeFilter.FILTER_ACCEPT" [@@bs.val];
  external _SHOW_ALL: float = "NodeFilter.SHOW_ALL" [@@bs.val];
  external _SHOW_DOCUMENT_TYPE: float = "NodeFilter.SHOW_DOCUMENT_TYPE" [@@bs.val];
  external _SHOW_TEXT: float = "NodeFilter.SHOW_TEXT" [@@bs.val];
  external _SHOW_ELEMENT: float = "NodeFilter.SHOW_ELEMENT" [@@bs.val];
  external _SHOW_COMMENT: float = "NodeFilter.SHOW_COMMENT" [@@bs.val];
  external _FILTER_SKIP: float = "NodeFilter.FILTER_SKIP" [@@bs.val];
  external _SHOW_ATTRIBUTE: float = "NodeFilter.SHOW_ATTRIBUTE" [@@bs.val];
  external _SHOW_DOCUMENT_FRAGMENT: float = "NodeFilter.SHOW_DOCUMENT_FRAGMENT" [@@bs.val];
};
let module CloseEvent = {
  type t;
  external create: unit => t = "CloseEvent" [@@bs.new]; 
  external code: float = "" [@@bs.get];
  external reason: string = "" [@@bs.get];
  external wasClean: bool = "" [@@bs.get];
};
let module WebSocket = {
  type t;
  external create: unit => t = "WebSocket" [@@bs.new]; 
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
  external constructor: t => (string => protocols::(option TODO) => unit) = "" [@@bs.send];
  external protocol: string = "" [@@bs.get];
  external readyState: float = "" [@@bs.get];
  external bufferedAmount: float = "" [@@bs.get];
  external onopen: (Event => 'a) = "" [@@bs.get];
  external extensions: string = "" [@@bs.get];
  external onmessage: (MessageEvent => 'a) = "" [@@bs.get];
  external onclose: (CloseEvent => 'a) = "" [@@bs.get];
  external onerror: (Event => 'a) = "" [@@bs.get];
  external binaryType: string = "" [@@bs.get];
  external url: string = "" [@@bs.get];
  external close: t => (code::(option float) => reason::(option string) => unit) = "" [@@bs.send];
  external send: t => ('a => unit) = "" [@@bs.send];
  let _CONNECTING = 0.;
  let _OPEN = 1.;
  let _CLOSING = 2.;
  let _CLOSED = 3.;
};
let module Worker = {
  type t;
  external create: unit => t = "Worker" [@@bs.new]; 
  external constructor: t => (string => unit) = "" [@@bs.send];
  external onerror: (Event => 'a) = "" [@@bs.get];
  external onmessage: (MessageEvent => 'a) = "" [@@bs.get];
  external postMessage: t => ('a => ports::(option 'a) => unit) = "" [@@bs.send];
  external terminate: t => (unit => unit) = "" [@@bs.send];
};
let module SharedWorker = {
  type t;
  external create: unit => t = "SharedWorker" [@@bs.new]; 
  external constructor: t => (string => unit) = "" [@@bs.send];
  external port: MessagePort = "" [@@bs.get];
  external onerror: (Event => 'a) = "" [@@bs.get];
};
external importScripts: (array 'rest => unit) = "importScripts" [@@bs.val];
let module WorkerGlobalScope = {
  type t;
  external create: unit => t = "WorkerGlobalScope" [@@bs.new]; 
  external self: WorkerGlobalScope = "" [@@bs.get];
  external location: WorkerLocation = "" [@@bs.get];
  external navigator: WorkerNavigator = "" [@@bs.get];
  external close: t => (unit => unit) = "" [@@bs.send];
  external importScripts: t => (array 'rest => unit) = "" [@@bs.send] [@@bs.splice];
  external onerror: (Event => 'a) = "" [@@bs.get];
  external onlanguagechange: (Event => 'a) = "" [@@bs.get];
  external onoffline: (Event => 'a) = "" [@@bs.get];
  external ononline: (Event => 'a) = "" [@@bs.get];
  external onrejectionhandled: (PromiseRejectionEvent => 'a) = "" [@@bs.get];
  external onunhandledrejection: (PromiseRejectionEvent => 'a) = "" [@@bs.get];
};
let module DedicatedWorkerGlobalScope = {
  type t;
  external create: unit => t = "DedicatedWorkerGlobalScope" [@@bs.new]; 
  external onmessage: t => (unit => (MessageEvent => 'a)) = "" [@@bs.send];
  external postMessage: t => ('a => transfer::(option Iterable) => unit) = "" [@@bs.send];
};
let module SharedWorkerGlobalScope = {
  type t;
  external create: unit => t = "SharedWorkerGlobalScope" [@@bs.new]; 
  external name: string = "" [@@bs.get];
  external onconnect: (MessageEvent => 'a) = "" [@@bs.get];
};
let module WorkerLocation = {
  type t;
  external create: unit => t = "WorkerLocation" [@@bs.new]; 
  external origin: string = "" [@@bs.get];
  external protocol: string = "" [@@bs.get];
  external host: string = "" [@@bs.get];
  external hostname: string = "" [@@bs.get];
  external port: string = "" [@@bs.get];
  external pathname: string = "" [@@bs.get];
  external search: string = "" [@@bs.get];
  external hash: string = "" [@@bs.get];
};
let module WorkerNavigator = {
  type t;
  external create: unit => t = "WorkerNavigator" [@@bs.new]; 
};
let module XDomainRequest = {
  type t;
  external create: unit => t = "XDomainRequest" [@@bs.new]; 
  external timeout: float = "" [@@bs.get];
  external onerror: (Event => 'a) = "" [@@bs.get];
  external onload: (Event => 'a) = "" [@@bs.get];
  external onprogress: (Event => 'a) = "" [@@bs.get];
  external ontimeout: (Event => 'a) = "" [@@bs.get];
  external responseText: string = "" [@@bs.get];
  external contentType: string = "" [@@bs.get];
  external open: t => (string => string => unit) = "" [@@bs.send];
  external abort: t => (unit => unit) = "" [@@bs.send];
  external send: t => (data::(option 'a) => unit) = "" [@@bs.send];
  external addEventListener: t => (string => ('a => unit) => useCapture::(option bool) => unit) = "" [@@bs.send];
  external statics: TODO = "" [@@bs.get];
};
let module XMLHttpRequest = {
  type t;
  external create: unit => t = "XMLHttpRequest" [@@bs.new]; 
  external responseBody: 'a = "" [@@bs.get];
  external status: float = "" [@@bs.get];
  external readyState: float = "" [@@bs.get];
  external responseText: string = "" [@@bs.get];
  external responseXML: 'a = "" [@@bs.get];
  external ontimeout: (ProgressEvent => 'a) = "" [@@bs.get];
  external statusText: string = "" [@@bs.get];
  external onreadystatechange: (Event => 'a) = "" [@@bs.get];
  external timeout: float = "" [@@bs.get];
  external onload: (ProgressEvent => 'a) = "" [@@bs.get];
  external response: 'a = "" [@@bs.get];
  external withCredentials: bool = "" [@@bs.get];
  external onprogress: (ProgressEvent => 'a) = "" [@@bs.get];
  external onabort: (ProgressEvent => 'a) = "" [@@bs.get];
  external responseType: string = "" [@@bs.get];
  external onloadend: (ProgressEvent => 'a) = "" [@@bs.get];
  external upload: XMLHttpRequestEventTarget = "" [@@bs.get];
  external onerror: (ProgressEvent => 'a) = "" [@@bs.get];
  external onloadstart: (ProgressEvent => 'a) = "" [@@bs.get];
  external msCaching: string = "" [@@bs.get];
  external open: t => (string => string => async::(option bool) => user::(option string) => password::(option string) => unit) = "" [@@bs.send];
  external send: t => (data::(option 'a) => unit) = "" [@@bs.send];
  external abort: t => (unit => unit) = "" [@@bs.send];
  external getAllResponseHeaders: t => (unit => string) = "" [@@bs.send];
  external setRequestHeader: t => (string => string => unit) = "" [@@bs.send];
  external getResponseHeader: t => (string => string) = "" [@@bs.send];
  external msCachingEnabled: t => (unit => bool) = "" [@@bs.send];
  external overrideMimeType: t => (string => unit) = "" [@@bs.send];
  external _LOADING: float = "" [@@bs.get];
  external _DONE: float = "" [@@bs.get];
  external _UNSENT: float = "" [@@bs.get];
  external _OPENED: float = "" [@@bs.get];
  external _HEADERS_RECEIVED: float = "" [@@bs.get];
  external statics: TODO = "" [@@bs.get];
};
let module XMLHttpRequestEventTarget = {
  type t;
  external create: unit => t = "XMLHttpRequestEventTarget" [@@bs.new]; 
  external onprogress: (ProgressEvent => 'a) = "" [@@bs.get];
  external onerror: (Event => 'a) = "" [@@bs.get];
  external onload: (Event => 'a) = "" [@@bs.get];
  external ontimeout: (Event => 'a) = "" [@@bs.get];
  external onabort: (Event => 'a) = "" [@@bs.get];
  external onloadstart: (Event => 'a) = "" [@@bs.get];
  external onloadend: (Event => 'a) = "" [@@bs.get];
};
let module XMLSerializer = {
  type t;
  external create: unit => t = "XMLSerializer" [@@bs.new]; 
  external serializeToString: t => (Node => string) = "" [@@bs.send];
};
let module Geolocation = {
  type t;
  external create: unit => t = "Geolocation" [@@bs.new]; 
  external getCurrentPosition: ((Position => 'a) => error::(option (PositionError => 'a)) => options::(option PositionOptions) => 'a) = "" [@@bs.get];
  external watchPosition: ((Position => 'a) => error::(option (PositionError => 'a)) => options::(option PositionOptions) => 'a) = "" [@@bs.get];
  external clearWatch: 'a = "" [@@bs.get];
};
let module Position = {
  type t;
  external create: unit => t = "Position" [@@bs.new]; 
  external coords: Coordinates = "" [@@bs.get];
  external timestamp: float = "" [@@bs.get];
};
let module Coordinates = {
  type t;
  external create: unit => t = "Coordinates" [@@bs.new]; 
  external latitude: float = "" [@@bs.get];
  external longitude: float = "" [@@bs.get];
  external altitude: float = "" [@@bs.get];
  external accuracy: float = "" [@@bs.get];
  external altitudeAccuracy: float = "" [@@bs.get];
  external heading: float = "" [@@bs.get];
};
let module PositionError = {
  type t;
  external create: unit => t = "PositionError" [@@bs.new]; 
  external code: float = "" [@@bs.get];
  external message: string = "" [@@bs.get];
  external _PERMISSION_DENIED: float = "" [@@bs.get];
  external _POSITION_UNAVAILABLE: float = "" [@@bs.get];
  external _TIMEOUT: float = "" [@@bs.get];
};
type TODO;
let module AudioContext = {
  type t;
  external create: unit => t = "AudioContext" [@@bs.new]; 
  external currentTime: float = "" [@@bs.get];
  external destination: AudioDestinationNode = "" [@@bs.get];
  external listener: AudioListener = "" [@@bs.get];
  external sampleRate: float = "" [@@bs.get];
  external state: 'a = "" [@@bs.get];
  external onstatechange: ('a => 'a) = "" [@@bs.get];
  external close: t => (unit => unit) = "" [@@bs.send];
  external createBuffer: t => (float => float => float => AudioBuffer) = "" [@@bs.send];
  external createBufferSource: t => (myMediaElement::(option HTMLMediaElement) => AudioBufferSourceNode) = "" [@@bs.send];
  external createMediaElementSource: t => (HTMLMediaElement => MediaElementAudioSourceNode) = "" [@@bs.send];
  external createMediaStreamSource: t => (unit => MediaStreamAudioSourceNode) = "" [@@bs.send];
  external createMediaStreamDestination: t => (unit => MediaStream) = "" [@@bs.send];
  external createScriptProcessor: t => (float => float => float => ScriptProcessorNode) = "" [@@bs.send];
  external createAnalyser: t => (unit => AnalyserNode) = "" [@@bs.send];
  external createBiquadFilter: t => (unit => BiquadFilterNode) = "" [@@bs.send];
  external createChannelMerger: t => (numberOfInputs::(option float) => ChannelMergerNode) = "" [@@bs.send];
  external createChannelSplitter: t => (numberOfInputs::(option float) => ChannelSplitterNode) = "" [@@bs.send];
  external createConvolver: t => (unit => ConvolverNode) = "" [@@bs.send];
  external createDelay: t => (maxDelayTime::(option float) => DelayNode) = "" [@@bs.send];
  external createDynamicCompressor: t => (unit => DynamicsCompressorNode) = "" [@@bs.send];
  external createGain: t => (unit => GainNode) = "" [@@bs.send];
  external createOscillator: t => (unit => OscillatorNode) = "" [@@bs.send];
  external createPanner: t => (unit => PannerNode) = "" [@@bs.send];
  external createPeriodicWave: t => (Float32Array => Float32Array => options::(option TODO) => PeriodicWave) = "" [@@bs.send];
  external createWaveShaper: t => (unit => WaveShaperNode) = "" [@@bs.send];
  external decodeAudioData: t => (ArrayBuffer => (unit => unit) => (unit => unit) => unit) = "" [@@bs.send];
  external decodeAudioData: t => (ArrayBuffer => Promise) = "" [@@bs.send];
  external resume: t => (unit => Promise) = "" [@@bs.send];
  external suspend: t => (unit => Promise) = "" [@@bs.send];
};
let module AudioNode = {
  type t;
  external create: unit => t = "AudioNode" [@@bs.new]; 
  external context: AudioContext = "" [@@bs.get];
  external numberOfInputs: float = "" [@@bs.get];
  external numberOfOutputs: float = "" [@@bs.get];
  external channelCount: float = "" [@@bs.get];
  external channelCoundMode: 'a = "" [@@bs.get];
  external channelInterpretation: TODO = "" [@@bs.get];
  external connect: t => (AudioNode => output::(option float) => input::(option float) => AudioNode) = "" [@@bs.send];
  external connect: t => (AudioParam => output::(option float) => unit) = "" [@@bs.send];
  external disconnect: t => (destination::(option AudioNode) => output::(option float) => input::(option float) => unit) = "" [@@bs.send];
};
let module AudioParam = {
  type t;
  external create: unit => t = "AudioParam" [@@bs.new]; 
  external value: float = "" [@@bs.get];
  external defaultValue: float = "" [@@bs.get];
  external setValueAtTime: t => (float => float => this) = "" [@@bs.send];
  external linearRampToValueAtTime: t => (float => float => this) = "" [@@bs.send];
  external exponentialRampToValueAtTime: t => (float => float => this) = "" [@@bs.send];
  external setTargetAtTime: t => (float => float => float => this) = "" [@@bs.send];
  external setValueCurveAtTime: t => (Float32Array => float => float => this) = "" [@@bs.send];
  external cancelScheduledValues: t => (float => this) = "" [@@bs.send];
};
let module AudioDestinationNode = {
  type t;
  external create: unit => t = "AudioDestinationNode" [@@bs.new]; 
  external maxChannelCount: float = "" [@@bs.get];
};
let module AudioListener = {
  type t;
  external create: unit => t = "AudioListener" [@@bs.new]; 
  external setOrientation: t => (float => float => float => float => float => float => unit) = "" [@@bs.send];
};
let module AudioBuffer = {
  type t;
  external create: unit => t = "AudioBuffer" [@@bs.new]; 
  external sampleRate: float = "" [@@bs.get];
  external length: float = "" [@@bs.get];
  external duration: float = "" [@@bs.get];
  external numberOfChannels: float = "" [@@bs.get];
  external getChannelData: t => (float => Float32Array) = "" [@@bs.send];
  external copyFromChannel: t => (Float32Array => float => startInChannel::(option float) => unit) = "" [@@bs.send];
  external copyToChannel: t => (Float32Array => float => startInChannel::(option float) => unit) = "" [@@bs.send];
};
let module AudioBufferSourceNode = {
  type t;
  external create: unit => t = "AudioBufferSourceNode" [@@bs.new]; 
  external buffer: AudioBuffer = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external loop: bool = "" [@@bs.get];
  external loopStart: float = "" [@@bs.get];
  external loopEnd: float = "" [@@bs.get];
  external playbackRate: AudioParam = "" [@@bs.get];
  external onended: ('a => 'a) = "" [@@bs.get];
  external start: t => (when::(option float) => offset::(option float) => duration::(option float) => unit) = "" [@@bs.send];
  external stop: t => (when::(option float) => unit) = "" [@@bs.send];
};
let module MediaStream = {
  type t;
  external create: unit => t = "MediaStream" [@@bs.new]; 
  external active: bool = "" [@@bs.get];
  external ended: bool = "" [@@bs.get];
  external id: string = "" [@@bs.get];
  external onactive: ('a => 'a) = "" [@@bs.get];
  external onaddtrack: ('a => 'a) = "" [@@bs.get];
  external onended: ('a => 'a) = "" [@@bs.get];
  external oninactive: ('a => 'a) = "" [@@bs.get];
  external onremovetrack: ('a => 'a) = "" [@@bs.get];
  external addTrack: t => (MediaStreamTrack => unit) = "" [@@bs.send];
  external clone: t => (unit => MediaStream) = "" [@@bs.send];
  external getAudioTracks: t => (unit => TODO) = "" [@@bs.send];
  external getTrackById: t => (trackid::(option string) => TODO) = "" [@@bs.send];
  external getTracks: t => (unit => TODO) = "" [@@bs.send];
  external getVideoTracks: t => (unit => TODO) = "" [@@bs.send];
  external removeTrack: t => (MediaStreamTrack => unit) = "" [@@bs.send];
};
let module MediaStreamTrack = {
  type t;
  external create: unit => t = "MediaStreamTrack" [@@bs.new]; 
  external enabled: bool = "" [@@bs.get];
  external id: string = "" [@@bs.get];
  external kind: string = "" [@@bs.get];
  external label: string = "" [@@bs.get];
  external muted: bool = "" [@@bs.get];
  external readonly: bool = "" [@@bs.get];
  external readyState: TODO = "" [@@bs.get];
  external remote: bool = "" [@@bs.get];
  external onstarted: ('a => 'a) = "" [@@bs.get];
  external onmute: ('a => 'a) = "" [@@bs.get];
  external onunmute: ('a => 'a) = "" [@@bs.get];
  external onoverconstrained: ('a => 'a) = "" [@@bs.get];
  external onended: ('a => 'a) = "" [@@bs.get];
  external getConstraints: t => (unit => 'a) = "" [@@bs.send];
  external applyConstraints: t => (unit => 'a) = "" [@@bs.send];
  external getSettings: t => (unit => 'a) = "" [@@bs.send];
  external getCapabilities: t => (unit => 'a) = "" [@@bs.send];
  external clone: t => (unit => MediaStreamTrack) = "" [@@bs.send];
  external stop: t => (unit => unit) = "" [@@bs.send];
};
let module MediaElementAudioSourceNode = {
  type t;
  external create: unit => t = "MediaElementAudioSourceNode" [@@bs.new]; 
};
let module MediaStreamAudioSourceNode = {
  type t;
  external create: unit => t = "MediaStreamAudioSourceNode" [@@bs.new]; 
};
let module ScriptProcessorNode = {
  type t;
  external create: unit => t = "ScriptProcessorNode" [@@bs.new]; 
  external bufferSize: float = "" [@@bs.get];
  external onaudioprocess: ('a => 'a) = "" [@@bs.get];
};
let module AnalyserNode = {
  type t;
  external create: unit => t = "AnalyserNode" [@@bs.new]; 
  external fftSize: float = "" [@@bs.get];
  external frequencyBinCount: float = "" [@@bs.get];
  external minDecibels: float = "" [@@bs.get];
  external maxDecibels: float = "" [@@bs.get];
  external smoothingTimeConstant: float = "" [@@bs.get];
  external getFloatFrequencyData: t => (Float32Array => Float32Array) = "" [@@bs.send];
  external getByteFrequencyData: t => (Uint8Array => Uint8Array) = "" [@@bs.send];
  external getFloatTimeDomainData: t => (Float32Array => Float32Array) = "" [@@bs.send];
  external getByteTimeDomainData: t => (Uint8Array => Uint8Array) = "" [@@bs.send];
};
let module BiquadFilterNode = {
  type t;
  external create: unit => t = "BiquadFilterNode" [@@bs.new]; 
  external frequency: AudioParam = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external _Q: AudioParam = "" [@@bs.get];
  external gain: AudioParam = "" [@@bs.get];
  external _type: TODO = "" [@@bs.get];
  external getFrequencyResponse: t => (Float32Array => Float32Array => Float32Array => BiquadFilterNode) = "" [@@bs.send];
};
let module ChannelMergerNode = {
  type t;
  external create: unit => t = "ChannelMergerNode" [@@bs.new]; 
};
let module ChannelSplitterNode = {
  type t;
  external create: unit => t = "ChannelSplitterNode" [@@bs.new]; 
};
let module ConvolverNode = {
  type t;
  external create: unit => t = "ConvolverNode" [@@bs.new]; 
  external buffer: AudioBuffer = "" [@@bs.get];
  external normalize: bool = "" [@@bs.get];
};
let module DelayNode = {
  type t;
  external create: unit => t = "DelayNode" [@@bs.new]; 
  external delayTime: float = "" [@@bs.get];
};
let module DynamicsCompressorNode = {
  type t;
  external create: unit => t = "DynamicsCompressorNode" [@@bs.new]; 
  external threshold: AudioParam = "" [@@bs.get];
  external knee: AudioParam = "" [@@bs.get];
  external ratio: AudioParam = "" [@@bs.get];
  external reduction: AudioParam = "" [@@bs.get];
  external attack: AudioParam = "" [@@bs.get];
  external release: AudioParam = "" [@@bs.get];
};
let module GainNode = {
  type t;
  external create: unit => t = "GainNode" [@@bs.new]; 
  external gain: AudioParam = "" [@@bs.get];
};
let module OscillatorNode = {
  type t;
  external create: unit => t = "OscillatorNode" [@@bs.new]; 
  external frequency: AudioParam = "" [@@bs.get];
  external detune: AudioParam = "" [@@bs.get];
  external _type: TODO = "" [@@bs.get];
  external start: t => (when::(option float) => unit) = "" [@@bs.send];
  external stop: t => (when::(option float) => unit) = "" [@@bs.send];
  external setPeriodicWave: t => (PeriodicWave => unit) = "" [@@bs.send];
};
let module PannerNode = {
  type t;
  external create: unit => t = "PannerNode" [@@bs.new]; 
  external panningModel: TODO = "" [@@bs.get];
  external distanceModel: TODO = "" [@@bs.get];
  external refDistance: float = "" [@@bs.get];
  external maxDistance: float = "" [@@bs.get];
  external rollofFactor: float = "" [@@bs.get];
  external coneInnerAngle: float = "" [@@bs.get];
  external coneOuterAngle: float = "" [@@bs.get];
  external coneOuterGain: float = "" [@@bs.get];
  external setPosition: t => (float => float => float => unit) = "" [@@bs.send];
  external setOrientation: t => (float => float => float => unit) = "" [@@bs.send];
};
let module PeriodicWave = {
  type t;
  external create: unit => t = "PeriodicWave" [@@bs.new]; 
};
let module WaveShaperNode = {
  type t;
  external create: unit => t = "WaveShaperNode" [@@bs.new]; 
  external curve: Float32Array = "" [@@bs.get];
  external oversample: TODO = "" [@@bs.get];
};
let module AudioContextInstance = {
  external currentTime: float = "AudioContext.currentTime" [@@bs.val];
  external destination: AudioDestinationNode = "AudioContext.destination" [@@bs.val];
  external listener: AudioListener = "AudioContext.listener" [@@bs.val];
  external sampleRate: float = "AudioContext.sampleRate" [@@bs.val];
  external state: 'a = "AudioContext.state" [@@bs.val];
  external onstatechange: ('a => 'a) = "AudioContext.onstatechange" [@@bs.val];
  external close: (unit => unit) = "AudioContext.close" [@@bs.send];
  external createBuffer: (float => float => float => AudioBuffer) = "AudioContext.createBuffer" [@@bs.send];
  external createBufferSource: (myMediaElement::(option HTMLMediaElement) => AudioBufferSourceNode) = "AudioContext.createBufferSource" [@@bs.send];
  external createMediaElementSource: (HTMLMediaElement => MediaElementAudioSourceNode) = "AudioContext.createMediaElementSource" [@@bs.send];
  external createMediaStreamSource: (unit => MediaStreamAudioSourceNode) = "AudioContext.createMediaStreamSource" [@@bs.send];
  external createMediaStreamDestination: (unit => MediaStream) = "AudioContext.createMediaStreamDestination" [@@bs.send];
  external createScriptProcessor: (float => float => float => ScriptProcessorNode) = "AudioContext.createScriptProcessor" [@@bs.send];
  external createAnalyser: (unit => AnalyserNode) = "AudioContext.createAnalyser" [@@bs.send];
  external createBiquadFilter: (unit => BiquadFilterNode) = "AudioContext.createBiquadFilter" [@@bs.send];
  external createChannelMerger: (numberOfInputs::(option float) => ChannelMergerNode) = "AudioContext.createChannelMerger" [@@bs.send];
  external createChannelSplitter: (numberOfInputs::(option float) => ChannelSplitterNode) = "AudioContext.createChannelSplitter" [@@bs.send];
  external createConvolver: (unit => ConvolverNode) = "AudioContext.createConvolver" [@@bs.send];
  external createDelay: (maxDelayTime::(option float) => DelayNode) = "AudioContext.createDelay" [@@bs.send];
  external createDynamicCompressor: (unit => DynamicsCompressorNode) = "AudioContext.createDynamicCompressor" [@@bs.send];
  external createGain: (unit => GainNode) = "AudioContext.createGain" [@@bs.send];
  external createOscillator: (unit => OscillatorNode) = "AudioContext.createOscillator" [@@bs.send];
  external createPanner: (unit => PannerNode) = "AudioContext.createPanner" [@@bs.send];
  external createPeriodicWave: (Float32Array => Float32Array => options::(option TODO) => PeriodicWave) = "AudioContext.createPeriodicWave" [@@bs.send];
  external createWaveShaper: (unit => WaveShaperNode) = "AudioContext.createWaveShaper" [@@bs.send];
  external decodeAudioData: (ArrayBuffer => (unit => unit) => (unit => unit) => unit) = "AudioContext.decodeAudioData" [@@bs.send];
  external decodeAudioData: (ArrayBuffer => Promise) = "AudioContext.decodeAudioData" [@@bs.send];
  external resume: (unit => Promise) = "AudioContext.resume" [@@bs.send];
  external suspend: (unit => Promise) = "AudioContext.suspend" [@@bs.send];
};
type TODO;
let module Headers = {
  type t;
  external create: unit => t = "Headers" [@@bs.new]; 
  external _@@iterator: t => (unit => Iterator) = "" [@@bs.send];
  external constructor: t => (init::(option HeadersInit) => unit) = "" [@@bs.send];
  external append: t => (string => string => unit) = "" [@@bs.send];
  external delete: t => (string => unit) = "" [@@bs.send];
  external entries: t => (unit => Iterator) = "" [@@bs.send];
  external get: t => (string => string) = "" [@@bs.send];
  external getAll: t => (string => Array) = "" [@@bs.send];
  external has: t => (string => bool) = "" [@@bs.send];
  external keys: t => (unit => Iterator) = "" [@@bs.send];
  external set: t => (string => string => unit) = "" [@@bs.send];
  external values: t => (unit => Iterator) = "" [@@bs.send];
};
let module URLSearchParams = {
  type t;
  external create: unit => t = "URLSearchParams" [@@bs.new]; 
  external _@@iterator: t => (unit => Iterator) = "" [@@bs.send];
  external constructor: t => (query::(option TODO) => unit) = "" [@@bs.send];
  external append: t => (string => string => unit) = "" [@@bs.send];
  external delete: t => (string => unit) = "" [@@bs.send];
  external entries: t => (unit => Iterator) = "" [@@bs.send];
  external get: t => (string => string) = "" [@@bs.send];
  external getAll: t => (string => Array) = "" [@@bs.send];
  external has: t => (string => bool) = "" [@@bs.send];
  external keys: t => (unit => Iterator) = "" [@@bs.send];
  external set: t => (string => string => unit) = "" [@@bs.send];
  external values: t => (unit => Iterator) = "" [@@bs.send];
};
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
type TODO;
let module Response = {
  type t;
  external create: unit => t = "Response" [@@bs.new]; 
  external constructor: t => (input::(option TODO) => init::(option ResponseOptions) => unit) = "" [@@bs.send];
  external clone: t => (unit => Response) = "" [@@bs.send];
  external error: (unit => Response) = "" [@@bs.val];
  external redirect: (string => float => Response) = "" [@@bs.val];
  external _type: ResponseType = "" [@@bs.get];
  external url: string = "" [@@bs.get];
  external useFinalURL: bool = "" [@@bs.get];
  external ok: bool = "" [@@bs.get];
  external status: float = "" [@@bs.get];
  external statusText: string = "" [@@bs.get];
  external headers: Headers = "" [@@bs.get];
  external bodyUsed: bool = "" [@@bs.get];
  external arrayBuffer: t => (unit => Promise) = "" [@@bs.send];
  external blob: t => (unit => Promise) = "" [@@bs.send];
  external formData: t => (unit => Promise) = "" [@@bs.send];
  external json: t => (unit => Promise) = "" [@@bs.send];
  external text: t => (unit => Promise) = "" [@@bs.send];
};
let module Request = {
  type t;
  external create: unit => t = "Request" [@@bs.new]; 
  external constructor: t => (TODO => init::(option RequestOptions) => unit) = "" [@@bs.send];
  external clone: t => (unit => Request) = "" [@@bs.send];
  external url: string = "" [@@bs.get];
  external cache: CacheType = "" [@@bs.get];
  external credentials: CredentialsType = "" [@@bs.get];
  external headers: Headers = "" [@@bs.get];
  external integrity: string = "" [@@bs.get];
  external method: MethodType = "" [@@bs.get];
  external mode: ModeType = "" [@@bs.get];
  external redirect: RedirectType = "" [@@bs.get];
  external referrer: string = "" [@@bs.get];
  external referrerPolicy: ReferrerPolicyType = "" [@@bs.get];
  external bodyUsed: bool = "" [@@bs.get];
  external arrayBuffer: t => (unit => Promise) = "" [@@bs.send];
  external blob: t => (unit => Promise) = "" [@@bs.send];
  external formData: t => (unit => Promise) = "" [@@bs.send];
  external json: t => (unit => Promise) = "" [@@bs.send];
  external text: t => (unit => Promise) = "" [@@bs.send];
};
external fetch: (TODO => init::(option RequestOptions) => Promise) = "fetch" [@@bs.val];
let module MessagePort = {
  type t;
  external create: unit => t = "MessagePort" [@@bs.new]; 
  external postMessage: t => ('a => transfer::(option Iterable) => unit) = "" [@@bs.send];
  external start: t => (unit => unit) = "" [@@bs.send];
  external close: t => (unit => unit) = "" [@@bs.send];
  external onmessage: (Event => 'a) = "" [@@bs.get];
};
let module MessageChannel = {
  type t;
  external create: unit => t = "MessageChannel" [@@bs.new]; 
  external port1: MessagePort = "" [@@bs.get];
  external port2: MessagePort = "" [@@bs.get];
};
